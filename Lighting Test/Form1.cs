using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Printing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Policy;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Media;


namespace Lighting_Test
{
    public partial class Form1 : Form
    {
        string gameState;
        //MainMenu - "To Exit press "Escape"" "To Play press "Enter"."
        //Gaming - game timer is true 
        //DeathMenu - "Respawn at last checkpoint - "Enter". Exit - "Escape"."

        SoundPlayer Sound = new SoundPlayer(Properties.Resources.Sound);

        #region GLOBAL VARIABLES
        //Shorthand
        int x = 0;
        int y = 1;
        int up = 0;
        int down = 1;
        int left = 2;
        int right = 3;

        //Current Level Renderer
        Action<bool> levelRenderer;

        //Random generator
        Random random = new Random();

        //Lists to store the current loaded tiles, and current tiles Colour Pallette:
        List<Rectangle> currentTiles = new List<Rectangle>();
        List<Rectangle> currentTilePixels = new List<Rectangle>();
        List<int> currentPixelDepths = new List<int>();
        List<int> currentTileDepths = new List<int>();
        List<Color> currentPixelColors = new List<Color>();

        List<Entity> currentEntities = new List<Entity>();

        List<Color> currentOverlayColors = new List<Color>();

        List<Rectangle> redrawList = new List<Rectangle>();

        //MOVING SPRITE GENERATION AND INFORMATOIN
        //A list to store currently moving sprites
        List<MovingSprite> movingSprites = new List<MovingSprite>();

        int maxSprites = 1;

        int largestSize, largestSubtraction, redAddition, greenAddition, blueAddition, bioluminescenceSize, sampleSuppressor, chanceOfSpawn, chanceOfRemoval;


        int sampleSpriteSize;
        Color sampleColor;

        //all lights on screen
        List<Light> lightList = new List<Light>();

        double[] trueRgb = new double[3];

        int tileWidth = 45;

        Graphics e;


        //storing current Level
        int currentLevelX = 0;
        int currentLevelY = 0;

        //Key info
        bool[] WSAD = new bool[] { false, false, false, false, false };
        Keys[] keysToCheck = new Keys[] { Keys.Space, Keys.S, Keys.A, Keys.D };

        //Player info:
        //Player physical bodies
        Rectangle player;
        Rectangle oldPlayer;
        Rectangle playerXCheck;
        Rectangle playerYCheck;

        //bullets
        int shots = 7;

        //Player movement:
        int[] xYDirection = new int[] { 0, 0 };
        int[] xYSpeed = new int[] { 6, 11 };
        int maxSpeedX = 11;
        int maxSpeedY = 35;

        string jumpState = "accelerating";

        int speedInteger = 8;
        int momentumGain = 3;
        int momentumLoss = 2;

        int previousJump = 0;
        int jumpInterval = 700;

        double lastFrameUpdate = 0;
        double frameUpdateInterval = 500;

        double lastAttack = 0;
        double attackInterval = 600;

        int[] canMoveUpDownLeftRight = new int[4] { 0, 0, 0, 0 };

        double previousImmunity = 0;

        int immunityFrames = 600;

        //Spawn points
        Point playerSpawn = new Point(580, 326);
        int[] playerSpawnLevel = new int[] { 0, 0 };

        //Temperary brushes, I would like to have 0 brushes up here by the time the project is over.
        SolidBrush whiteBrush = new SolidBrush(Color.White);


        double clickBegin;
        double clickEnd;

        Stopwatch stopwatch = new Stopwatch();
        #endregion

        #region ALL LEVELS
        Level[][] allLevels = new Level[][]
        {
            //Each new Level[] is a new row, each level in that row signifies a place in a columb. In this way I can track the X and Y position of each level
            //Y = 0
        new Level[]
        {
            #region 0,0
            new Level
            (
                new List<int>{
                    30,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                4,4,1,1,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                4,4,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                4,4,1,1,19,1,1,1,1,1,1,1,1,1,1,1,19,1,4,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,19,1,1,1,1,1,1,1,1,1,1,1,19,4,4,1,1,1,1,1,1,1,4,4,4,4,
                4,5,1,19,19,1,1,1,1,1,1,1,1,1,1,1,19,19,19,1,1,1,1,1,1,1,4,4,4,4,
                4,6,1,19,19,1,1,1,1,1,1,1,1,1,1,1,19,19,19,1,1,1,2,4,4,4,4,4,4,4,
                4,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,1,1,3,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,3,3,3,3,4,4,4,4,4,4,3,1,1,4,4,4,4,4,4,4,4,
                4,4,9,10,10,10,10,10,10,10,10,10,10,10,1,1,1,1,1,1,1,1,1,1,1,1,1,1,19,1,
                4,6,3,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,19,1,
                4,4,3,2,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,1,1,4,4,4,
                4,6,3,3,3,2,3,3,3,3,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,3,2,2,3,2,2,3,3,6,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                },
                new List<int>
                {
                    30,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,
                0,0,2,3,3,3,3,2,2,3,3,4,5,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,1,2,3,3,2,2,1,2,3,3,4,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                    new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 170, 200, 130, 80, 0),
                },
                 new List<Entity>
                {
                     new Entity
                     (
                         new MovingSprite(new Rectangle(30, 560, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                 },
                   new int[]
            {
        1, //largestSize
        1,  //largestSubtraction
        40, //redAddition
        1, //greenAddition
        1, //blueAddition
        2,  //bioluminescenceSize

        1,  //sampleSuppressor

        0, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
            #endregion
            #region 0,1
            new Level
            (
                new List<int>{
                    30,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                4,4,1,4,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                4,4,4,4,4,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,4,4,4,4,4,4,4,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                1,1,1,1,1,4,4,4,4,4,4,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,19,1,
                1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,19,1,
                4,4,1,1,1,1,4,4,4,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,3,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,4,4,1,1,1,1,1,1,4,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                    30,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,7,7,7,1,1,10,10,100,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                1,1,7,7,7,1,1,10,10,100,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                1,1,7,7,7,40,100,100,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,-30,-1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                0,0,10,20,30,40,50,60,70,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,
                0,0,7,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,
                0,0,7,7,7,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -60, 0, -180 }, 170, 200, 130, 80, 0),
                      new Light(new Rectangle(580, 318, 0, 0), new int[] { -180, -60, 0 }, 170, 230, 130, 180, 0),
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 100, 220, 40, 10, 0),
                new Light(new Rectangle(982, 220, 0, 0), new int[] { -12, -6, -39 }, 3, 230, 20, 5, 1),
                },
                 new List<Entity>
                {
                      new Entity
                     (
                         new MovingSprite(new Rectangle(360, 120, 20, 20), new int[]{1,1}, new int[]{1,-1},Color.Orange, 0), 1
                     ),
                         new Entity
                     (
                         new MovingSprite(new Rectangle(800, 160, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                            new Entity
                     (
                         new MovingSprite(new Rectangle(540, 560, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                               new Entity
                     (
                         new MovingSprite(new Rectangle(930, 360, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                },
                   new int[]
            {
             10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 0,2
            new Level
            (
                new List<int>{
                                 30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                        4,4,4,4,2,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,3,3,1,1,2,4,3,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                        4,4,3,2,2,1,1,1,3,1,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,19,1,
                        4,4,1,1,3,1,1,1,1,1,2,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,19,1,
                        4,4,1,1,2,1,2,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,19,19,19,19,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,4,4,4,4,4,4,
                        4,4,4,4,4,19,19,19,19,4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4,4,4,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,4,4,1,1,1,1,1,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,19,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,19,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                  30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,2,2,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -180, -60, 0 }, 170, 200, 130, 80, 0),
                       new Light(new Rectangle(980, 820, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 0)
    },
                 new List<Entity>
                {
                      new Entity
                     (
                         new MovingSprite(new Rectangle(360, 120, 20, 20), new int[]{1,1}, new int[]{1,-1},Color.Orange, 0), 1
                     ),
                         new Entity
                     (
                         new MovingSprite(new Rectangle(800, 160, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                            new Entity
                     (
                         new MovingSprite(new Rectangle(40, 560, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                },
                   new int[]
            {
                10, //largestSize
        1,  //largestSubtraction
        1, //redAddition
        40, //greenAddition
        30, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 0,3
            new Level
            (
                new List<int>{
                                 30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                        4,4,1,1,2,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,2,1,1,2,2,2,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                        1,4,2,2,2,1,1,2,2,2,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        1,1,1,1,2,1,2,1,1,1,2,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,2,1,2,1,1,1,2,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        3,2,1,1,1,1,1,1,1,1,1,1,1,1,4,2,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,4,4,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                  30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        2,2,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        1,1,1,1,7,1,7,1,1,1,7,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -10, -160, 0 }, 170, 200, 130, 80, 0),
                       new Light(new Rectangle(0, -100, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 1),
                       new Light(new Rectangle(1000, -100, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 0),
    },
                 new List<Entity>
                {
                                           new Entity
                     (
                         new MovingSprite(new Rectangle(360, 120, 20, 20), new int[]{1,1}, new int[]{1,-1},Color.Orange, 0), 1
                     ),
                         new Entity
                     (
                         new MovingSprite(new Rectangle(800, 160, 40, 40), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 0
                     ),
                           new Entity
                     (
                         new MovingSprite(new Rectangle(600, 160, 50, 50), new int[]{4,1}, new int[]{1,0},Color.Red, 0), 1
                     ),
                },
                   new int[]
            {
               10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
        },
        
        //Y = 1
        new Level[]
        {
            #region 1,0
            new Level
            (
                new List<int>{
                  30,
                        16,16,16,16,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,17,17,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,16,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,18,7,18,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,11,18,18,18,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,15,15,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,13,13,13,13,7,7,7,15,7,7,7,7,7,7,7,7,7,7,7,7,7,7,19,7,
                        7,7,7,7,17,7,18,7,14,14,14,13,7,13,7,7,7,7,7,7,7,7,7,7,7,7,7,7,19,7,
                        7,7,7,7,17,18,18,7,7,7,18,7,14,7,14,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,11,
                },
                new List<int>
                {
                          30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,8,6,5,5,1,1,1,1,0,1,2,3,4,5,6,7,0,0,0,0,0,0,0,0,
                        0,0,1,3,7,9,9,7,7,7,1,1,1,1,1,3,4,4,6,7,8,8,1,1,1,0,0,0,0,0,
                        0,0,7,7,7,9,9,7,7,7,5,5,1,1,0,3,4,5,6,7,8,9,1,1,1,1,1,0,0,0,
                        0,0,1,3,7,9,7,4,5,5,7,5,1,1,0,2,2,4,5,4,7,1,1,1,1,1,1,0,0,0,
                        0,0,1,3,7,9,7,4,1,1,7,1,1,0,0,0,0,0,5,5,6,1,1,1,1,1,1,0,0,0,
                        0,0,1,3,3,3,3,4,1,1,1,1,0,0,0,1,2,3,2,4,5,1,1,1,1,1,0,0,0,0,
                        0,0,1,2,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,1,4,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,1,1,2,3,3,7,1,1,1,7,1,1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,0,1,
                        0,1,2,3,4,4,7,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,4,3,2,1,1,1,0,1,
                        0,0,3,4,5,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,6,5,4,3,1,0,0,0,0,
                        0,0,2,3,4,5,1,1,1,1,1,1,1,1,0,1,1,1,1,1,4,5,4,3,2,1,0,0,0,0,
                        0,0,1,2,3,4,1,1,1,1,1,1,1,1,0,1,1,1,1,1,3,4,3,2,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                    new Light(new Rectangle(580, 320, 0, 0), new int[] { 40000,400000,40000 },4440, 2400, 4130, 8440, 0),
                          new Light(new Rectangle(580, 320, 0, 0), new int[] { -180, -60, 0 }, 170, 230, 130, 80, 1),
                    new Light(new Rectangle(380, 120, 0, 0), new int[] { 32, 0, 29 }, 80, 200, 50, 30, 0),
                    new Light(new Rectangle(380, 120, 0, 0), new int[] { 32, 0, 29 }, 80, 210, 50, 30, 0),
                    new Light(new Rectangle(180,120, 0, 0), new int[] { 32, 12, -29 }, 80, 200, 50, 30, 0),

                },
                 new List<Entity>
                {
                          new Entity
                     (
                         new MovingSprite(new Rectangle(560, 420, 100, 100), new int[]{2,3}, new int[]{-1,1},Color.Lime, 0), 0
                     ),

                },
                   new int[]
            {
               10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
            #endregion
            #region 1,1
            new Level
            (
                new List<int>{
                      30,
                        16,16,16,16,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,17,17,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,16,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,18,7,18,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,11,18,18,18,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,15,15,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,13,13,13,13,7,7,7,15,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,18,7,14,14,14,13,7,13,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,18,7,7,7,18,7,14,7,14,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,18,11,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,17,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,11,

                },
                new List<int>
                {
       30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        0,0,7,7,7,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                        1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                                      new Light(new Rectangle(580, 320, 0, 0), new int[] { 40000,400000,40000 },4440, 2400, 4130, 8440, 0),
                //new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 100, 220, 40, 10, 0),
                new Light(new Rectangle(980, 620, 0, 0), new int[] { -122, -26, -329 }, 70, 200, 40, 5, 0),
                },
                 new List<Entity>
                {
                },
                   new int[]
            {
        50, //largestSize
        1,  //largestSubtraction
        10, //redAddition
        50, //greenAddition
        20, //blueAddition
        5,  //bioluminescenceSize

        4,  //sampleSuppressor

        45, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 1,2
            new Level
            (
                new List<int>{
                                  30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,1,1,1,1,1,1,1,4,7,1,7,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,7,7,7,1,1,1,1,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,
                        4,4,7,7,7,1,1,7,7,7,1,1,1,1,4,7,1,1,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,1,1,1,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,4,4,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,4,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,4,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                               30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,0,7,1,7,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,7,7,7,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
                        0,0,7,7,7,1,1,7,7,7,1,1,1,1,0,7,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -52, 3, -180 }, 100, 230, 10, 130, 0),
                       new Light(new Rectangle(980, 520, 0, 0), new int[] { -60, -120, -180 }, 10, 240, 40, 10, 0),
                         new Light(new Rectangle(380, 420, 0, 0), new int[] { -60, -120, -180 }, 60, 100, 40, 10, -1)
    },
                 new List<Entity>
                {
                },
                   new int[]
            {
                10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        20, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                )
#endregion
        },
        
        //Y = 2
        new Level[]
        {

        },
        };
        #endregion
        #region ALL TILE PATTERNS:
        int[][] tilePatterns = new int[][]
        {
        new int[]{
            3,
            10,10,10,
            16,10,16,
            10,10,100,
        },
        new int[]{
           3,
              6,6,6,
            10,100,10,
            6,6,6,
        },
         new int[]{
            3,
            2,2,2,
            1,1,2,
            1,2,2,
        },
             new int[]{
            3,
            1,0,0,
            0,1,0,
            0,0,1,
        },
        new int[]{
            3,
            1,1,1,
            1,0,1,
            1,1,1,
        },
          new int[]{
            3,
     1,0,1,
     1,3,1,
     1,1,1,
        },
              new int[]{
            3,
            1,0,1,
            2,3,2,
            3,2,0,
        },
              new int[]{ //7
            15,
          1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,4,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,3,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,3,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,3,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,2,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,2,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,3,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,2,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,3,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
        },
            new int[]{ //8
            3,
            3,2,4,
            2,3,2,
            1,1,0,
        },
               new int[]{ // 9
            3,
            0,1,8,
            1,5,6,
            10,13,12,
        },
                    new int[]{ // 10
            3,
            1,1,1,
            7,8,7,
            10,8,12,
        },
                       new int[]{ //11
            15,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        },
            new int[]{ //12
            15,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,3,4,4,2,2,3,4,4,2,2,3,4,4,2,
            2,4,2,3,2,2,4,2,3,2,2,4,2,3,2,
            2,3,4,3,2,2,3,4,3,2,2,3,4,3,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        },
               new int[]{ //13
             15,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            1,1,3,5,1,3,5,1,3,5,1,3,5,1,1,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,1,
            1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            1,1,3,5,1,3,5,1,3,5,1,3,5,1,1,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,1,
            1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            1,1,3,5,1,3,5,1,3,5,1,3,5,1,1,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,1,
            1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            1,1,3,5,1,3,5,1,3,5,1,3,5,1,1,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,1,
            1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        },
                 new int[]{ //14
             15,
         1,2,1,2,1,1,2,1,2,1,1,2,1,2,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,1,0,1,3,3,1,0,1,3,3,1,0,1,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,2,3,2,3,3,2,3,2,3,3,2,3,2,1,
         1,2,3,2,3,3,2,3,2,3,3,2,3,2,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,1,0,1,3,3,1,0,1,3,3,1,0,1,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,2,3,2,3,3,2,3,2,3,3,2,3,2,1,
         1,2,3,2,3,3,2,3,2,3,3,2,3,2,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,1,0,1,3,3,1,0,1,3,3,1,0,1,1,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         1,2,1,2,1,1,2,1,2,1,1,2,1,2,1,
                 },
                 new int[]{ //15
             15,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,1,2,1,1,2,1,2,1,1,2,1,2,1,
                 },
                           new int[]{ //16
             15,
            1,0,0,1,1,2,1,1,1,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,1,2,0,
            0,1,1,1,0,0,1,1,0,0,0,1,1,1,0,

                           },
                                new int[]{ //17
             15,
             1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,
             1,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,4,5,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,4,0,0,0,0,0,1,
             1,1,2,3,2,1,0,2,2,0,0,0,0,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,
             1,1,4,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,0,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,4,5,1,1,5,0,0,0,1,0,0,0,1,
             1,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             1,2,1,0,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,2,0,4,1,0,0,0,0,1,
             1,0,0,0,2,1,0,0,0,2,0,0,0,0,1,
             1,1,1,1,1,1,2,1,2,1,1,1,1,2,1,
                 },
                                new int[]{ //18
             15,
             0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,
             0,0,10,0,0,0,0,0,0,0,11,10,0,0,1,
             1,4,1,12,5,1,0,0,2,5,1,2,3,2,1,
             1,0,0,1,11,1,0,0,4,0,10,0,10,0,1,
             2,1,2,3,1,1,5,2,2,0,10,0,10,0,1,
             1,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,1,0,0,0,1,0,10,0,1,
             2,1,4,0,21,11,10,2,10,2,1,10,10,10,1,
             1,2,10,2,5,1,2,3,3,5,1,2,3,2,1,
             1,10,4,5,1,1,5,7,10,2,1,10,10,10,0,
             1,10,10,10,2,1,1,3,3,2,3,10,10,10,1,
             2,2,1,0,5,1,2,3,4,5,1,2,3,2,1,
             2,10,10,10,1,1,2,10,5,5,10,10,3,10,1,
             1,10,10,10,2,1,10,10,10,2,10,10,10,3,1,
             1,1,3,2,2,1,2,3,2,1,1,1,1,2,1,
                 },
                                 new int[]{ //19
             5,
             1,2,2,2,1,
             3,0,2,0,3,
             2,2,0,3,2,
             2,0,3,0,2,
             1,3,4,3,1,

                 },
        };
        #endregion
        #region ALL SPRITES
        int[][][] sprites = new int[][][]
        {
            #region entity0
              new int[][]{
        
            #region Frame0
                  new int[]
                  {
                  2,1,1,1,1,
                  1,1,0,1,0,
                  1,1,0,1,0,
                  2,2,1,1,1,
                  2,2,2,1,1,
                  },
            #endregion
            #region Frame1
                   new int[]
                  {
                  2,1,1,1,1,
                  1,1,0,1,0,
                  1,1,0,1,0,
                  2,2,1,1,1,
                  2,2,2,1,1,
                  },
            #endregion
            #region Frame2
                    new int[]
                  {
                  2,1,1,1,1,
                  1,1,1,1,1,
                  1,1,0,1,0,
                  2,2,1,1,1,
                  2,2,2,1,1,
                  },
            #endregion

              },            
              #endregion
            #region entity1
              new int[][]{
        
            #region Frame0
                  new int[]
                  {
                  1,1,1,1,1,
                  1,1,0,1,0,
                  1,1,0,1,0,
                  1,1,1,1,1,
                  2,1,1,2,1,
                  },
            #endregion
            #region Frame1
                   new int[]
                  {
                  1,1,1,1,1,
                  1,1,0,1,0,
                  1,1,0,1,0,
                  1,1,1,1,1,
                  2,1,2,1,1,
                  },
            #endregion
              },            
              #endregion
            #region entity2
              new int[][]{
        
            #region Frame0
                  new int[]
                  {
                  0,0,2,2,2,
                  1,1,1,0,0,
                  1,1,1,1,1,
                  1,1,1,0,0,
                  0,0,2,2,2,
                  },
            #endregion
            #region Frame1
                   new int[]
                  {
                  0,2,2,2,2,
                  1,1,0,0,2,
                  1,1,1,1,0,
                  1,1,0,0,2,
                  0,2,2,2,2,
                  },
            #endregion
                      #region Frame2
                   new int[]
                  {
                  2,2,2,2,2,
                  1,0,0,2,2,
                  1,1,1,0,2,
                  1,0,0,2,2,
                  2,2,2,2,2,
                  },
            #endregion
              },            
              #endregion
            #region entity3
              new int[][]{
        
            #region Frame0
                  new int[]
                  {
                  2,1,1,1,2,
                  1,1,1,1,1,
                  1,1,1,1,1,
                  1,1,1,1,1,
                  2,1,1,1,2,
                  },
            #endregion
            #region Frame1
                   new int[]
                  {
                  2,2,1,2,2,
                  2,1,1,1,2,
                  1,1,1,1,1,
                  2,1,1,1,2,
                  2,2,1,2,2,
                  },
            #endregion
                      #region Frame2
                   new int[]
                  {
                  2,2,2,2,2,
                  2,2,1,2,2,
                  2,1,1,1,2,
                  2,2,1,2,2,
                  2,2,2,2,2,
                  },
            #endregion
              },            
              #endregion
        };
        #endregion

        #region Load
        public Form1()
        {
            InitializeComponent();
            player = new Rectangle(580, 320, 0, 0);
            playerXCheck = new Rectangle(0, 0, 0, 0);
            playerYCheck = new Rectangle(0, 0, 0, 0);
            createLevel();

            stopwatch.Start();

        }
        #endregion

        #region Game Timer
        private void gameTimer_Tick(object sender, EventArgs e)
        {
            if (stopwatch.ElapsedMilliseconds < 300 && stopwatch.ElapsedMilliseconds > 200)
            {
                UpdateGameState("MainMenu");
                return;
            }

            #region Adding Atmospheric Moving Sprites
            //Add vines or plants growing!
            if (random.Next(0, 101) > chanceOfSpawn && movingSprites.Count < maxSprites)
            {
                sampleSpriteSize = random.Next(0, largestSize) / random.Next(1, largestSubtraction);
                int smallerSize = sampleSpriteSize / random.Next(2, 8);
                int red = random.Next(0, redAddition);
                int green = random.Next(0, greenAddition);
                int blue = random.Next(0, blueAddition);
                int yLoc = 0;

                movingSprites.Add(new MovingSprite(new Rectangle(random.Next(0, this.Width - sampleSpriteSize), yLoc, sampleSpriteSize, sampleSpriteSize), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, Color.FromArgb(red, green, blue), random.Next(-3, 13)));
                movingSprites.Add(new MovingSprite(new Rectangle(random.Next(0, this.Width - smallerSize), yLoc - smallerSize, smallerSize, smallerSize), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, Color.FromArgb(red / 2, green / 2, blue / 2), random.Next(-3, 13)));
            }

            if (random.Next(0, 101) > chanceOfRemoval && movingSprites.Count > 0)
            {
                if (movingSprites[0].body.Width > 16 && movingSprites.Count < maxSprites)
                {
                    movingSprites.Add(new MovingSprite(new Rectangle(movingSprites[0].body.X + movingSprites[0].body.Width / 2, movingSprites[0].body.Y, movingSprites[0].body.Width / 4, movingSprites[0].body.Width / 4), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, movingSprites[0].color, random.Next(0, 3)));
                }
                movingSprites.RemoveAt(0);
            }
            #endregion
            #region Movement
            oldPlayer = player;

            if (stopwatch.ElapsedMilliseconds % speedInteger == 0)
            {
                //Find out how fast the player should be moving Horizontally!
                //gaining momentum based on walking time
                if (xYSpeed[x] < maxSpeedX && xYDirection[x] != 0) { xYSpeed[x] += momentumGain; }
                //losing momentum over time
                else if (xYSpeed[x] > momentumLoss && xYDirection[x] == 0) { xYSpeed[x] -= momentumLoss; }
            }


            if (WSAD[0] == true && canMoveUpDownLeftRight[down] == 1)
            {
                newJump();
            }
            //Resting: jump speed is at 0
            else if (canMoveUpDownLeftRight[down] == 1)
            {
                xYSpeed[y] = 3;
            }
            //Lifting: decrease speed
            if (jumpState == "decelerating")
            {
                xYDirection[y] = -1;
                if (xYSpeed[y] > 2)
                {
                    xYSpeed[y] -= 2;
                }

                if (WSAD[0] == false || stopwatch.ElapsedMilliseconds - previousJump > jumpInterval / 2 || (canMoveUpDownLeftRight[up] == -1 && stopwatch.ElapsedMilliseconds - previousJump > jumpInterval / 3))
                {
                    xYSpeed[y] = 0;
                    jumpState = "accelerating";
                }
            }
            //Falling: increase speed
            if (jumpState == "accelerating")
            {
                xYDirection[y] = 1;
                if (xYSpeed[y] < maxSpeedY)
                {
                    xYSpeed[y] += 2;
                }
            }

            #endregion
            #region Determing All Object Directions
            //Determening player directions depending on what keys are pressed:
            if (WSAD[left] == true && WSAD[right] == false)
            {
                xYDirection[x] = -1;
            }
            else if (WSAD[left] == false && WSAD[right] == true)
            {
                xYDirection[x] = 1;
            }
            else
            {
                xYDirection[x] = 0;
            }
            #endregion


            #region Entities with for loop
            moveEntities();
            #endregion
            //Frame updates
            if (stopwatch.ElapsedMilliseconds > lastFrameUpdate + frameUpdateInterval)
            {
                lastFrameUpdate = stopwatch.ElapsedMilliseconds;
                foreach (Entity entity in currentEntities)
                {
                    //Add one to the sprites animation frame value
                    entity.spriteInfo[1]++;
                    //If this number is greater than the amount of frames associated with the sprite, reset the sprite animation to 0.
                    if (entity.spriteInfo[1] >= sprites[entity.spriteInfo[0]].Length)
                    {
                        entity.spriteInfo[1] = 0;
                    }
                }
            }

            #region Move Player TRY 2

            canMoveUpDownLeftRight[up] = 0;
            canMoveUpDownLeftRight[down] = 0;
            canMoveUpDownLeftRight[left] = 0;
            canMoveUpDownLeftRight[right] = 0;

            //Rectangle to check the players next move
            Rectangle proposedMove = new Rectangle(player.X, player.Y, player.Width, player.Height);

            //Move the rectangle to be in players position
            int Xmove = xYDirection[x] * xYSpeed[x];
            int Ymove = xYDirection[y] * xYSpeed[y];

            proposedMove.X += Xmove;
            proposedMove.Y += Ymove;

            //For each tile, does the new move interstect with it?
            for (int n = 0; n < currentTiles.Count; n++)
            {
                #region UpDownLeftRight
                //CAN PLAYER GO UP DOWN LEFT RIGHT
                if (playerYCheck.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    //TOP WALL
                    if (playerYCheck.Y >= currentTiles[n].Y && n + 30 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 30] != 0)
                    {
                        canMoveUpDownLeftRight[up] = -1;
                    }
                    //BOTTOM WALL
                    if (playerYCheck.Y <= currentTiles[n].Y && n - 30 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 30] != 0)
                    {

                        canMoveUpDownLeftRight[down] = 1;

                    }
                }
                if (playerXCheck.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    //LEFT WALL
                    if (playerXCheck.X >= currentTiles[n].X && n + 1 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 1] != 0)
                    {
                        canMoveUpDownLeftRight[left] = -1;
                    }
                    //RIGHT WALL
                    if (playerXCheck.X <= currentTiles[n].X && n - 1 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 1] != 0)
                    {
                        canMoveUpDownLeftRight[right] = 1;
                    }
                }
                #endregion

                if (proposedMove.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    int Xdistance = Math.Abs((currentTiles[n].X + (currentTiles[n].Width / 2)) - (player.X + (player.Width / 2)));
                    int Ydistance = Math.Abs((currentTiles[n].Y + (currentTiles[n].Height / 2)) - (player.Y + (player.Height / 2)));

                    //If the player would not be where they are supposed to be.. find how far they can go!
                    //LEFT WALL
                    if (player.X >= currentTiles[n].X && n + 1 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 1] != 0 && Xdistance > Ydistance)
                    {
                        Xmove = (player.X - (currentTiles[n].Width + currentTiles[n].X)) * -1;
                    }
                    //RIGHT WALL
                    else if (player.X <= currentTiles[n].X && n - 1 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 1] != 0 && Xdistance > Ydistance)

                    {
                        Xmove = currentTiles[n].X - player.X - player.Width;
                    }
                    //TOP WALL
                    else if (player.Y >= currentTiles[n].Y && n + 30 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 30] != 0 && Xdistance < Ydistance)
                    {
                        Ymove = (player.Y - (currentTiles[n].Y + currentTiles[n].Height)) * -1;
                    }
                    //BOTTOM WALL
                    else if (player.Y <= currentTiles[n].Y && n - 30 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 30] != 0 && Xdistance < Ydistance)
                    {
                        Ymove = currentTiles[n].Y - player.Y - player.Height;
                    }
                }
            }
            //Finally move the player.

            if (xYDirection[x] != canMoveUpDownLeftRight[left] && xYDirection[x] != canMoveUpDownLeftRight[right])
            {
                player.X += Xmove;
            }

            if (xYDirection[y] != canMoveUpDownLeftRight[up] && xYDirection[y] != canMoveUpDownLeftRight[down])
            {
                player.Y += Ymove;
            }

            #endregion
            #region Passing Through Levels
            if (player.Y <= player.Height / 2)
            {
                player.Y = this.Height - player.Height;
                currentLevelY--;
                createLevel();
                newJump();
            }
            if (player.Y >= this.Height - player.Height / 2)
            {
                player.Y = player.Height;
                currentLevelY++;
                createLevel();
            }
            if (player.X <= player.Height / 2)
            {
                player.X = this.Width - player.Height;
                currentLevelX--;
                createLevel();
            }
            if (player.X >= this.Width - player.Height / 2)
            {
                player.X = player.Height;
                currentLevelX++;
                createLevel();
            }
            #endregion

            //Tracking player accessories
            playerXCheck.Location = new Point(player.X - 1, player.Y);
            playerYCheck.Location = new Point(player.X, player.Y - 1);
            lightList[0].body.Location = new Point(player.X + (player.Width / 2), player.Y + (player.Width / 2));

            //Redraw Level, but if the game state has changed make sure to not redraw over top
            if (gameState == "Gaming")
            {
                levelRenderer(false);
            }

            //Move Moving Sprites
            for (int i = 0; i < movingSprites.Count; i++)
            {
                //move the sprite
                movingSprites[i].body.Y += movingSprites[i].xySpeed[y];
                //if the sprite is off the screen remove the sprite
                if (movingSprites[i].body.Y > this.Height - movingSprites[i].body.Height)
                {
                    movingSprites.RemoveAt(i);
                }
            }
            redrawList.Add(oldPlayer);
        }
        #endregion

        #region Key Checks
        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {
            //Check all keys and if they are down set the boolian value to true
            checkKey(true, e);

            if (e.KeyCode == Keys.Escape && gameState != "Gaming")
            {
                Application.Exit();
            }

            if (e.KeyCode == Keys.Enter && gameState != "Gaming")
            {
                UpdateGameState("Gaming");
                Respawn();
            }
        }

        private void Form1_KeyUp(object sender, KeyEventArgs e)
        {
            //Check all keys and if they are up set the boolian value to false
            checkKey(false, e);
        }

        void checkKey(bool trueOrFalse, KeyEventArgs e)
        {
            for (int i = 0; i < keysToCheck.Length; i++)
            {
                if (e.KeyCode == keysToCheck[i])
                {
                    WSAD[i] = trueOrFalse;
                }
            }


        }
        #endregion
        #region Create Level
        private void createLevel()
        {
            Level level = allLevels[currentLevelY][currentLevelX];


            #region vines

            largestSize = level.vineInfo[0];
            largestSubtraction = level.vineInfo[1];
            redAddition = level.vineInfo[2];
            greenAddition = level.vineInfo[3];
            blueAddition = level.vineInfo[4];
            bioluminescenceSize = level.vineInfo[5];
            sampleSuppressor = level.vineInfo[6];
            chanceOfSpawn = level.vineInfo[7];
            chanceOfRemoval = level.vineInfo[8];

            #endregion

            this.Width = tileWidth * 30;
            this.Height = tileWidth * ((level.depths.Count - 1) / 30);
            this.CenterToScreen();
            //Reset the current loaded level
            currentTiles.Clear();
            currentPixelDepths.Clear();
            currentTileDepths.Clear();
            currentTilePixels.Clear();
            currentPixelColors.Clear();
            movingSprites.Clear();
            currentOverlayColors = level.OverlayColors;
            currentEntities = level.entities;
            lightList = level.lights;


            //levelY keeps track of the 'Y' axis of the tile we are placing in the level
            int levelY = 0;
            //n represents the current tile
            for (int n = 0; n < level.depths.Count; n++)
            {
                //levelX works like levelY but for the x coodinate; first it is set to tile value, and then has the board width subtracted from it until it fits from 1 to level[0]
                int levelX = n;
                while (levelX > level.depths[0])
                {
                    levelX -= level.depths[0];
                }
                int rectangleX = ((levelX - 1) * tileWidth);
                int rectangleY = ((levelY - 1) * tileWidth);

                //Now that we have the x and y point of the rectangle, put it into physical space
                currentTiles.Add(new Rectangle(rectangleX, rectangleY, tileWidth, tileWidth));

                //Now we have a boundary for where the player can go, we still need to place in the image
                if (n > 0 && n <= 540)
                {
                    int thisTile = level.tileSprites[n];
                    int tilePixelY = 0;
                    int pixelDimension = tileWidth / tilePatterns[thisTile][0];

                    for (int m = 0; m < tilePatterns[thisTile].Length; m++)
                    {
                        int tilePixelX = m;
                        while (tilePixelX > tilePatterns[thisTile][0])
                        {
                            tilePixelX -= tilePatterns[thisTile][0];
                        }

                        int pixelX = (tilePixelX - 1) * pixelDimension;
                        int pixelY = (tilePixelY - 1) * pixelDimension;
                        //Now that we have the x and y point of the rectangle, put it (one pixel of the rectangle) into physical space, aswell as adding the integer storing its color value into its list.
                        if (m > 0)
                        {
                            currentTilePixels.Add(new Rectangle(pixelX + rectangleX, pixelY + rectangleY, pixelDimension, pixelDimension));
                            currentPixelDepths.Add(tilePatterns[thisTile][m] + (level.depths[n]));
                            currentTileDepths.Add(level.depths[n]);
                            currentPixelColors.Add(Color.Black);
                        }
                        if ((m) % (tilePatterns[thisTile][0]) == 0)
                        {
                            //If we get to the end of a row, add one to levelY to move us down a row, and reset levelX to 1 (the begining of the row)
                            tilePixelY++;
                        }
                    }
                }
                if ((n) % (level.depths[0]) == 0)
                {
                    //If we get to the end of a row, add one to levelY to move us down a row, and reset levelX to 1 (the begining of the row)
                    levelY++;
                }

            }
            if (level.OverlayColors.Count == currentPixelColors.Count)
            { }
            else
            {
                currentOverlayColors.Clear();
                for (int i = 0; i < currentPixelColors.Count; i++) { level.OverlayColors.Add(Color.FromArgb(255, 255, 255, 255)); };
            }
            currentOverlayColors = level.OverlayColors;

            int playerSize = Convert.ToInt32(tileWidth * 0.7);
            player.Size = new Size(playerSize, playerSize);

            lightList[0].body.Location = new Point(player.X - playerSize / 2, player.Y - playerSize / 2);
            playerXCheck = new Rectangle(0, 0, playerSize + 2, playerSize); ;
            playerYCheck = new Rectangle(0, 0, playerSize, playerSize + 2);
            //Define Graphics
            e = this.CreateGraphics();

            //If we are in a large level
            if (currentTilePixels.Count > 70000)
            {
                //set the current paint method to a large room renderer
                levelRenderer = largePaint;

            }
            //otherwise
            else
            {
                //set the current paint method to a large room renderer
                levelRenderer = smallPaint;
            }
            levelRenderer(true);

            previousImmunity = stopwatch.ElapsedMilliseconds;
        }
        #endregion

        double GetLength(Rectangle rectangle1, Rectangle rectangle2)
        {

            double x1 = rectangle1.X + (rectangle1.Width / 2);
            double x2 = rectangle2.X + (rectangle2.Width / 2);
            double y1 = rectangle1.Y + (rectangle1.Height / 2);
            double y2 = rectangle2.Y + (rectangle2.Height / 2);

            //A^2 = B^2 + C^2
            double length = Math.Sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
            return length;
        }

        //This version of paint doesnt refresh the screen each time! instead of drawing 5000 pixels it only draws the ones that change! This took my 'Process Memory' panel output number from 56 to 32!

        #region Large Paint
        void largePaint(bool loadWholeLevel)
        {
            drawBulletCount();
            drawEntities();
            if (loadWholeLevel) { Refresh(); }

            //For each rectangle on screen
            for (int n = 0; n < currentTilePixels.Count; n++)
            {
                VineGrowth(n);

                //REDRAWING

                int redrawSample = redrawCheck(currentTilePixels[n], redrawList);

                #region Establishing Pixel Color
                if (loadWholeLevel == true || redrawSample != -1)
                {
                    //Reset the trueRgb array
                    trueRgb = new double[3] { 0, 0, 0 };

                    if (currentOverlayColors[n] != Color.FromArgb(255, 255, 255, 255)) { sampleColor = currentOverlayColors[n]; }
                    else
                    {
                        //For each light that can affect the rectangle (lights on screen)
                        for (int i = Convert.ToInt32(loadWholeLevel); i < lightList.Count; i++)
                        {
                            //For each Red, Green, Or blue value of the rectangle's color
                            for (int num = 0; num < 3; num++)
                            {
                                //If the rectangle is in range of the light (rectangle would not be siloughetted by the light in 3D space)
                                if (currentPixelDepths[n] > lightList[i].depth)
                                {
                                    lightList[i].rgbStorage[num] = (20000 / GetLength(lightList[i].body, currentTilePixels[n]) / (currentPixelDepths[n] - (lightList[i].depth))) + lightList[i].rgbAffectors[num];
                                }
                                if (lightList[i].rgbStorage[num] > lightList[i].lightenPoint) { lightList[i].rgbStorage[num] += 20; }
                                if (lightList[i].rgbStorage[num] > lightList[i].maxBright) { lightList[i].rgbStorage[num] = lightList[i].maxBright; }
                                if (lightList[i].rgbStorage[num] < lightList[i].darkenPoint) { lightList[i].rgbStorage[num] -= 12; }
                                if (lightList[i].rgbStorage[num] < lightList[i].blackPoint) { lightList[i].rgbStorage[num] = 0; }
                            }
                            //Now that we have found the way the lights affect all pixels, find the brightest light per pixel
                            for (int j = 0; j < 3; j++)
                            {
                                if (lightList[i].rgbStorage[j] > trueRgb[j] && currentTileDepths[n] >= lightList[i].depth)
                                {
                                    trueRgb[j] = lightList[i].rgbStorage[j];
                                }
                            }
                        }
                        sampleColor = (Color.FromArgb(Convert.ToInt32(trueRgb[0]), Convert.ToInt32(trueRgb[1]), Convert.ToInt32(trueRgb[2])));
                    }
                    #endregion


                    if (redrawSample != -1)
                    {
                        Rectangle intersectingBody = new Rectangle(-10, -10, 0, 0);
                        if (player.IntersectsWith(currentTilePixels[n]))
                        {
                            intersectingBody = player;
                        }
                        foreach (Entity entity in currentEntities)
                        {
                            if (entity.sprite.body.IntersectsWith(currentTilePixels[n]))
                            {
                                intersectingBody = entity.sprite.body;
                                break;
                            }
                        }

                        if (intersectingBody.Width > 0)
                        {
                            List<Rectangle> redrawRectSampleList = redrawPixelRects(currentTilePixels[n], intersectingBody);

                            foreach (Rectangle rect in redrawRectSampleList)
                            {
                                e.FillRectangle(new SolidBrush(sampleColor), rect);
                            }
                        }
                        else
                        {
                            e.FillRectangle(new SolidBrush(sampleColor), currentTilePixels[n]);
                        }
                    }

                    //To avoid drawing things over again (This is reducing lag!)
                    else if (currentPixelColors[n] != sampleColor)
                    {
                        currentPixelColors[n] = sampleColor;
                        e.FillRectangle(new SolidBrush(sampleColor), currentTilePixels[n]);
                    }

                }
            }

            e.FillRectangle(whiteBrush, player);
            redrawList.Clear();
        }
        #endregion

        #region Small Paint
        void smallPaint(bool loadWholeLevel)
        {
            drawBulletCount();
            drawEntities();

            if (loadWholeLevel) { Refresh(); }

            //For each rectangle on screen
            for (int n = 0; n < currentTilePixels.Count; n++)
            {
                VineGrowth(n);

                //Reset the trueRgb array
                trueRgb = new double[3] { 0, 0, 0 };


                if (currentOverlayColors[n] != Color.FromArgb(255, 255, 255, 255) && ((currentOverlayColors[n].R + currentOverlayColors[n].G + currentOverlayColors[n].B) / 3) < 150)
                {
                    sampleColor = currentOverlayColors[n];
                }
                else
                {
                    //For each light that can affect the rectangle (lights on screen)
                    for (int i = Convert.ToInt32(loadWholeLevel); i < lightList.Count; i++)
                    {
                        //For each Red, Green, Or blue value of the rectangle's color
                        for (int num = 0; num < 3; num++)
                        {
                            //If the rectangle is in range of the light (rectangle would not be siloughetted by the light in 3D space)
                            if (currentTileDepths[n] >= lightList[i].depth && currentPixelDepths[n] > lightList[i].depth)
                            {
                                lightList[i].rgbStorage[num] = (20000 / GetLength(lightList[i].body, currentTilePixels[n]) / (currentPixelDepths[n] - (lightList[i].depth))) + lightList[i].rgbAffectors[num];
                            }
                            if (lightList[i].rgbStorage[num] > lightList[i].lightenPoint) { lightList[i].rgbStorage[num] += 20; }
                            if (lightList[i].rgbStorage[num] > lightList[i].maxBright) { lightList[i].rgbStorage[num] = lightList[i].maxBright; }
                            if (lightList[i].rgbStorage[num] < lightList[i].darkenPoint) { lightList[i].rgbStorage[num] -= 12; }
                            if (lightList[i].rgbStorage[num] < lightList[i].blackPoint) { lightList[i].rgbStorage[num] = 0; }
                        }
                        //Now that we have found the way the lights affect all pixels, find the brightest light per pixel
                        for (int j = 0; j < 3; j++)
                        {
                            if (lightList[i].rgbStorage[j] > trueRgb[j] && currentTileDepths[n] >= lightList[i].depth)
                            {
                                trueRgb[j] = lightList[i].rgbStorage[j];
                            }
                        }
                    }
                    sampleColor = (Color.FromArgb(Convert.ToInt32(trueRgb[0]), Convert.ToInt32(trueRgb[1]), Convert.ToInt32(trueRgb[2])));
                }



                int redrawSample = redrawCheck(currentTilePixels[n], redrawList);
                if (redrawSample != -1)
                {
                    Rectangle intersectingBody = new Rectangle(-10, -10, 0, 0);
                    if (player.IntersectsWith(currentTilePixels[n]))
                    {
                        intersectingBody = player;
                    }
                    foreach (Entity entity in currentEntities)
                    {
                        if (entity.sprite.body.IntersectsWith(currentTilePixels[n]))
                        {
                            intersectingBody = entity.sprite.body;
                            break;
                        }
                    }

                    if (intersectingBody.Width > 0)
                    {
                        List<Rectangle> redrawRectSampleList = redrawPixelRects(currentTilePixels[n], intersectingBody);

                        foreach (Rectangle rect in redrawRectSampleList)
                        {
                            e.FillRectangle(new SolidBrush(sampleColor), rect);
                        }
                    }
                    else
                    {
                        e.FillRectangle(new SolidBrush(sampleColor), currentTilePixels[n]);
                    }
                }

                //To avoid drawing things over again (This is reducing lag!)
                else if (currentPixelColors[n] != sampleColor)
                {
                    currentPixelColors[n] = sampleColor;
                    e.FillRectangle(new SolidBrush(currentPixelColors[n]), currentTilePixels[n]);
                }
            }
            e.FillRectangle(new SolidBrush(Color.White), player);
            redrawList.Clear();
        }
        #endregion

        void newJump()
        {
            xYDirection[y] = -1;
            xYSpeed[y] = maxSpeedY;
            previousJump = Convert.ToInt32(stopwatch.ElapsedMilliseconds);
            jumpState = "decelerating";
        }

        int checkList(int n, List<MovingSprite> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (currentTilePixels[n].IntersectsWith(list[i].body))
                {
                    if (list[i].depth < currentTileDepths[n]) { return i; }
                    else if (list[i].depth > 1) { list[i].depth--; }
                }
            }
            return -1;
        }

        int redrawCheck(Rectangle rectangle, List<Rectangle> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (rectangle.IntersectsWith(list[i]) && player.Contains(rectangle) == false && entityContains(rectangle) == false)
                {
                    return i;
                }
            }
            return -1;
        }

        private void Form1_MouseDown(object sender, MouseEventArgs e)
        {
            clickBegin = stopwatch.ElapsedMilliseconds;
        }

        bool entityContains(Rectangle rectangle)
        {
            foreach (Entity entity in currentEntities)
            {
                if (entity.sprite.body.Contains(rectangle))
                {
                    return true;
                }
            }
            return false;
        }

        void drawEntities()
        {
            foreach (Entity entity in currentEntities)
            {
                drawEntity(entity);
            }
        }

        void drawEntity(Entity entity)
        {
            int startX = entity.sprite.body.X;
            int startY = entity.sprite.body.Y;

            int width = 5;
            int size = entity.sprite.body.Width / width;

            int colorChange = Convert.ToInt32(255 / width);
            int sprite = entity.spriteInfo[0];
            int frame = entity.spriteInfo[1];
            int pixel = -1;

            for (int i = 0; i < width; i++)
            {
                if (entity.sprite.xyDirection[x] == 1)
                {
                    for (int j = 0; j < width; j += 1)
                    {
                        pixel++;
                        Rectangle sampleRect = new Rectangle(startX + (j * size), startY + (i * size), size, size);
                        Color color = Color.Cyan;
                        if (sprites[sprite][frame][pixel] == 1) { color = Color.White; }
                        else if (sprites[sprite][frame][pixel] == 0) { color = Color.DarkRed; }
                        else { color = Color.Black; }
                        e.FillRectangle(new SolidBrush(color), sampleRect);
                    }
                }
                else if (entity.sprite.xyDirection[x] == -1)
                {
                    for (int j = width - 1; j > -1; j += -1)
                    {
                        pixel++;
                        Rectangle sampleRect = new Rectangle(startX + (j * size), startY + (i * size), size, size);
                        Color color = Color.Cyan;
                        if (sprites[sprite][frame][pixel] == 1) { color = Color.White; }
                        else if (sprites[sprite][frame][pixel] == 0) { color = Color.DarkRed; }
                        else { color = Color.Black; }
                        e.FillRectangle(new SolidBrush(color), sampleRect);
                    }
                }
            }
        }

        void playerAttack(Size range)
        {
            int speed = Convert.ToInt32(range.Width / 2);
            //Attack position based on entity: Start with entity position, and add attack position based on entity direction
            int xDir = 1;
            Point _player = new Point(player.X + player.Width / 2, player.Y + player.Height / 2);


            #region Attack based on mouse
            Point mouse = new Point(Cursor.Position.X + ((this.Width - Screen.FromControl(this).Bounds.Width) / 2), Cursor.Position.Y + ((this.Height - Screen.FromControl(this).Bounds.Height) / 2));

            int xDiff = (mouse.X - _player.X);
            if (xDiff != 0 && Math.Abs(xDiff) > 30)
            {
                xDir = xDiff / Math.Abs(xDiff);
            }
            #endregion

            Point attackPoint = new Point((_player.X - range.Width / 2) + (xDir * range.Width), (_player.Y - range.Height / 2) - player.Height / 3);

            //Create instance of attack entity
            currentEntities.Add(
                new Entity(
                    new MovingSprite(
                        new Rectangle(attackPoint, range),
                        new int[] { speed, 0 },
                        new int[] { xDir, 0 },
                        Color.Red,
                        0),
                    4000,
                    Convert.ToInt32(stopwatch.ElapsedMilliseconds),
                    2
                    ));

            Sound.Play();
        }

        private void Form1_MouseClick(object sender, MouseEventArgs e)
        {
            clickEnd = stopwatch.ElapsedMilliseconds;

            if (stopwatch.ElapsedMilliseconds - lastAttack > attackInterval && shots > 0)
            {
                int size = Convert.ToInt32((clickEnd - clickBegin) / 20);
                if (size < 10) { size = 10; }
                else if (size > 43) { size = 43; }
                playerAttack(new Size(size, size));
                lastAttack = stopwatch.ElapsedMilliseconds;
                shots--;
            }
        }


        #region MovingSpriteStuff (vines)
        void VineGrowth(int n)
        {
            //Finds if there is a spot in the Moving Sprites list where the pixel overlaps with a sprite
            int intersectsWith = checkList(n, movingSprites);
            if (intersectsWith != -1) //IF THERE IS AN INTERSECTION:
            {
                //Redraws the pixel if outside the radius of the moving sprite
                if (GetLength(movingSprites[intersectsWith].body, currentTilePixels[n]) > movingSprites[intersectsWith].body.Width / 1.9 && levelRenderer == largePaint)
                {
                    currentOverlayColors[n] = currentPixelColors[n];
                }
                //otherwise draws the pixel as part of the moving sprite
                else if (currentTileDepths[n] >= movingSprites[intersectsWith].depth)
                {
                    //Now we are drawing the actual rectangle:
                    if (movingSprites[intersectsWith].body.Width > bioluminescenceSize) //if the rectangle should get brighter
                    {
                        int[] beforeColor = new int[]
                            {
                            currentPixelColors[n].R + movingSprites[intersectsWith].color.R + sampleColor.R / sampleSuppressor,
                            currentPixelColors[n].G + movingSprites[intersectsWith].color.G + sampleColor.G / sampleSuppressor,
                            currentPixelColors[n].B + movingSprites[intersectsWith].color.B + sampleColor.B / sampleSuppressor
                            };

                        for (int i = 0; i < 3; i++)
                        {
                            if (beforeColor[i] >= 255 || beforeColor[i] <= 1)
                            {
                                beforeColor[i] = (currentPixelColors[n].R + currentPixelColors[n].B + currentPixelColors[n].G) / 3;
                            }
                        }
                        //e.FillRectangle(new SolidBrush(Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2])), currentTilePixels[n]);
                        currentOverlayColors[n] = Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2]);
                    }
                    else //otherwise
                    {

                        int[] beforeColor = new int[]
                        {
                            ((currentPixelColors[n].R + movingSprites[intersectsWith].color.R + sampleColor.R / 4)),
                            ((currentPixelColors[n].G + movingSprites[intersectsWith].color.G + sampleColor.G / 4)),
                            ((currentPixelColors[n].B + movingSprites[intersectsWith].color.B + sampleColor.B / 4))
                        };

                        for (int i = 0; i < 3; i++)
                        {
                            if (currentTileDepths[n] == 0 || movingSprites[intersectsWith].depth < 1)
                            {
                                beforeColor[i] += 50;
                            }
                            if (beforeColor[i] >= 255 || beforeColor[i] <= 1)
                            {
                                beforeColor[i] = (currentPixelColors[n].R + currentPixelColors[n].B + currentPixelColors[n].G) / 3;
                            }
                        }
                        //e.FillRectangle(new SolidBrush(Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2])), currentTilePixels[n]);
                        currentOverlayColors[n] = Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2]);

                    }

                }
                e.FillRectangle(new SolidBrush(currentOverlayColors[n]), currentTilePixels[n]);
            }

        }
        #endregion

        #region Redrawing check rectangles
        List<Rectangle> redrawPixelRects(Rectangle pixel, Rectangle entity)
        {
            //First make the list that will be returned
            List<Rectangle> allRedraws = new List<Rectangle>();
            if (pixel.IntersectsWith(entity))
            {
                //Mark down the top left and bottom right points of the entity and pixel rectangle
                //Entity:
                int ex1 = entity.X;
                int ey1 = entity.Y;
                int ex2 = entity.X + entity.Width;
                int ey2 = entity.Y + entity.Height;
                //Pixel:
                int px1 = pixel.X;
                int py1 = pixel.Y;
                int px2 = pixel.X + pixel.Width;
                int py2 = pixel.Y + pixel.Height;

                //Compare the points to see where they overlap, this will be the rectangle inside the pixel we DONT want to clear.
                int x1 = Math.Max(ex1, px1);
                int y1 = Math.Max(ey1, py1);
                int x2 = Math.Min(ex2, px2);
                int y2 = Math.Min(ey2, py2);

                //Compare the rectangle of entity inside the pixel to all the pixels walls to add the appropriate amount of rectangles into the redraw list.
                if (x1 > px1) { allRedraws.Add(new Rectangle(px1, py1, x1 - px1, py2 - py1)); }
                if (y1 > py1) { allRedraws.Add(new Rectangle(px1, py1, px2 - px1, y1 - py1)); }
                if (x2 < px2) { allRedraws.Add(new Rectangle(x2, py1, px2 - x2, py2 - py1)); }
                if (y2 < py2) { allRedraws.Add(new Rectangle(px1, y2, px2 - x1, py2 - y2)); }
            }
            return allRedraws;
        }
        #endregion
        void moveEntities()
        {
            for (int f = 0; f < currentEntities.Count; f++)
            {

                {
                    redrawList.Add(new Rectangle(currentEntities[f].sprite.body.X, currentEntities[f].sprite.body.Y, currentEntities[f].sprite.body.Width, currentEntities[f].sprite.body.Height));

                    //Intersections (with player)
                    if (currentEntities[f].sprite.body.IntersectsWith(player) && currentEntities[f].immortal == true && stopwatch.ElapsedMilliseconds - previousImmunity > immunityFrames)
                    {
                        UpdateGameState("DeathMenu");
                        return;
                    }

                    //Intersections (with projectiles)
                    for (int g = 0; g < currentEntities.Count; g++)
                    {
                        if (currentEntities[f].sprite.body.IntersectsWith(currentEntities[g].sprite.body) && currentEntities[f].sprite.body != currentEntities[g].sprite.body && currentEntities[g].immortal == false)
                        {
                            double currentTime = stopwatch.ElapsedMilliseconds;
                            if (currentTime - currentEntities[f].previousHit > immunityFrames)
                            {
                                currentEntities[f].previousHit = currentTime;
                                currentEntities[f].health--;
                                if (currentEntities[f].health < 1)
                                {
                                    Entity ghostCreature = currentEntities[f];
                                    // Entity ghostBullet = currentEntities[g];

                                    currentEntities.Remove(ghostCreature);

                                    // currentEntities.Remove(ghostBullet);
                                    shots += 5;
                                    //   currentEntities.Add(new Entity(ghostCreature.sprite, 300, Convert.ToInt16(stopwatch.ElapsedMilliseconds), 1));
                                    f--;
                                    if (f < 0) { return; }
                                    break;
                                }
                                else
                                {
                                    currentEntities[f].spriteInfo = new int[] { 3, 0 };
                                    currentEntities[f].adjustSpeeds(Convert.ToInt32(currentTime), player);
                                    currentEntities[f].maxSpeedX = 6;
                                }

                            }
                        }
                    }

                    //Should the enemy despawn?
                    if (currentEntities[f].immortal == false && stopwatch.ElapsedMilliseconds - currentEntities[f].birth > currentEntities[f].lifespan)
                    {
                        currentEntities.Remove(currentEntities[f]);
                        f--;
                        if (f < 0) { return; }
                        continue;
                    }

                    if (currentEntities[f].immortal == false)
                    {
                        for (int tile = 0; tile < currentTiles.Count; tile++)
                        {
                            if (currentEntities[f].sprite.body.IntersectsWith(currentTiles[tile]) && allLevels[currentLevelY][currentLevelX].depths[tile] == 0 && allLevels[currentLevelY][currentLevelX].tileSprites[tile] == 19)
                            {
                                allLevels[currentLevelY][currentLevelX].depths[tile] = 1;
                                for (int pixel = 0; pixel < currentTileDepths.Count; pixel++)
                                {
                                    if (currentTilePixels[pixel].IntersectsWith(currentTiles[tile]))
                                    {
                                        currentPixelDepths[pixel] += 1;
                                        currentTileDepths[pixel] = 1;
                                    }
                                }
                                redrawList.Add(currentTiles[tile]);
                            }
                        }
                    }


                    //Check for moving through levels
                    int levelXChange = currentEntities[f].levelPassCheck(this.Height, this.Width).Item1;
                    int levelYChange = currentEntities[f].levelPassCheck(this.Height, this.Width).Item2;
                    int xCoord = currentEntities[f].levelPassCheck(this.Height, this.Width).Item3;
                    int yCoord = currentEntities[f].levelPassCheck(this.Height, this.Width).Item4;

                    //if entity has passed through a level, change its position, add it to the level, and remove them from this current level
                    if (levelXChange != 0 || levelYChange != 0)
                    {
                        currentEntities[f].sprite.body.Location = new Point(xCoord, yCoord);
                        allLevels[currentLevelY + levelYChange][currentLevelX + levelXChange].entities.Add(currentEntities[f]);
                        currentEntities.Remove(currentEntities[f]);
                        f--;
                        if (f < 0) { return; }
                        continue;
                    }
                    else
                    {

                        //Move entities
                        currentEntities[f].adjustSpeeds(Convert.ToInt32(stopwatch.ElapsedMilliseconds), player);
                        currentEntities[f].moveEntity(currentTiles, currentLevelY, currentLevelX, allLevels);

                    }
                }
            }
        }

        void drawBulletCount()
        {
            string bulletCount = $"x{shots}";
            Point position = new Point(player.Location.X, player.Y);
            label1.Text = bulletCount;
            label1.Size = player.Size;
            label1.Location = player.Location;

        }

        void Respawn()
        {
            Rectangle oldPlayer = player;

            currentLevelX = playerSpawnLevel[x];
            currentLevelY = playerSpawnLevel[y];
            createLevel();
            player.Location = playerSpawn;

            redrawList.Add(oldPlayer);
        }

        void UpdateGameState(string state)
        {

            gameState = state;

            //baller -Hark
            if (state == "DeathMenu")
            {
                label1.Visible = false;
                gameTimer.Enabled = false;

                for (int x = 0; x < 10; x++) { e.FillRectangle(new SolidBrush(Color.FromArgb(50, 0, 0, 0)), new Rectangle(0, 0, this.Width, this.Height)); }

                string text = "Respawn at last checkpoint - \"Enter\".\nExit - \"Escape\".\nDefeat Enemies for BULLETS.";
                Font font = new Font("Bitter", this.Width / (text.Length / 3), FontStyle.Bold);
                for (int x = 0; x < 2; x++)
                {
                    e.DrawString(text, font, new SolidBrush(Color.FromArgb(50, 255, 255, 255)), 0, this.Height / 2);
                }


                text = "YOU DIED";
                font = new Font("Bitter", this.Width / (text.Length), FontStyle.Bold);
                for (int x = 0; x < 2; x++)
                {
                    e.DrawString(text, font, new SolidBrush(Color.FromArgb(50, 255, 255, 255)), 0, 10);
                }
            }
            else if (state == "MainMenu")
            {
                label1.Visible = false;
                gameTimer.Enabled = false;

                for (int x = 0; x < 10; x++) { e.FillRectangle(new SolidBrush(Color.FromArgb(50, 0, 0, 0)), new Rectangle(0, 0, this.Width, this.Height)); }

                string text = "Move - W A S D.\nAttack - Left Clicks.\nCharge - Hold Left.\nPlay - Enter\nExit - Escape";
                Font font = new Font("Bitter", this.Width / (text.Length / 3), FontStyle.Bold);
                for (int x = 0; x < 2; x++)
                {
                    e.DrawString(text, font, new SolidBrush(Color.FromArgb(50, 255, 255, 255)), 0, this.Height / 2);
                }


                text = "EXPLORATION GAME";
                font = new Font("Bitter", this.Width / (text.Length), FontStyle.Bold);
                for (int x = 0; x < 2; x++)
                {
                    e.DrawString(text, font, new SolidBrush(Color.FromArgb(50, 255, 255, 255)), 0, 10);
                }
            }
            else
            {
                gameTimer.Enabled = true;
                label1.Visible = true;
            }
        }
    }
}
