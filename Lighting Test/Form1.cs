using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Printing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Policy;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;


namespace Lighting_Test
{
    public partial class Form1 : Form
    {
        #region GLOBAL VARIABLES
        //Shorthand
        int x = 0;
        int y = 1;
        int up = 0;
        int down = 1;
        int left = 2;
        int right = 3;

        //Current Level Renderer
        Action<bool> levelRenderer;

        //Random generator
        Random random = new Random();

        //Lists to store the current loaded tiles, and current tiles Colour Pallette:
        List<Rectangle> currentTiles = new List<Rectangle>();
        List<Rectangle> currentTilePixels = new List<Rectangle>();
        List<int> currentPixelDepths = new List<int>();
        List<int> currentTileDepths = new List<int>();
        List<Color> currentPixelColors = new List<Color>();

        List<Entity> currentEntities = new List<Entity>();

        List<Color> currentOverlayColors = new List<Color>();

        List<Rectangle> redrawList = new List<Rectangle>();

        //MOVING SPRITE GENERATION AND INFORMATOIN
        //A list to store currently moving sprites
        List<MovingSprite> movingSprites = new List<MovingSprite>();

        int maxSprites = 1;

        int largestSize, largestSubtraction, redAddition, greenAddition,blueAddition, bioluminescenceSize, sampleSuppressor, chanceOfSpawn, chanceOfRemoval;


        int sampleSpriteSize;
        Color sampleColor;

        //all lights on screen
        List<Light> lightList = new List<Light>();

        double[] trueRgb = new double[3];

        int tileWidth = 45;

        Graphics e;


        //storing current Level
        int currentLevelX = 0;
        int currentLevelY = 0;

        //Key info
        bool[] WSAD = new bool[] { false, false, false, false, false };
        Keys[] keysToCheck = new Keys[] { Keys.Space, Keys.S, Keys.A, Keys.D };

        //Player info:
        //Player physical bodies
        Rectangle player;
        Rectangle oldPlayer;
        Rectangle playerXCheck;
        Rectangle playerYCheck;

        //Player movement:
        int[] xYDirection = new int[] { 0, 0 };
        int[] xYSpeed = new int[] { 6, 11 };
        int maxSpeedX = 11;
        int maxSpeedY = 35;

        string jumpState = "accelerating";

        int speedInteger = 8;
        int momentumGain = 3;
        int momentumLoss = 2;

        int previousJump = 0;
        int jumpInterval = 700;

        int[] canMoveUpDownLeftRight = new int[4] { 0, 0, 0, 0 };


        //Spawn points
        Point playerSpawn = new Point(580, 326);
        int playerSpawnLevel = 0;

        //Temperary brushes, I would like to have 0 brushes up here by the time the project is over.
        SolidBrush redBrush = new SolidBrush(Color.Red);
        SolidBrush blueBrush = new SolidBrush(Color.DodgerBlue);
        SolidBrush whiteBrush = new SolidBrush(Color.White);

        //How large is a row of levels? (how many levels are in a row of levels?) 
        int levelLayoutWidth = 3;

        Stopwatch stopwatch = new Stopwatch();
        #endregion

        #region ALL LEVELS
        Level[][] allLevels = new Level[][]
        {
            //Each new Level[] is a new row, each level in that row signifies a place in a columb. In this way I can track the X and Y position of each level
            //Y = 0
        new Level[]
        {
            #region 0,0
            new Level
            (
                new List<int>{
                    30,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                4,4,1,1,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                4,4,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,1,4,4,4,4,
                4,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,
                4,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,3,3,1,1,1,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,3,3,3,3,4,4,4,4,4,4,3,1,1,4,4,4,4,4,4,4,4,
                4,4,9,10,10,10,10,10,10,10,10,10,10,10,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                4,6,3,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                4,4,3,2,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,1,1,4,4,4,
                4,6,3,3,3,2,3,3,3,3,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,3,2,2,3,2,2,3,3,6,6,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                },
                new List<int>
                {
                    30,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,
                0,0,2,3,3,3,3,2,2,3,3,4,5,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,1,2,3,3,2,2,1,2,3,3,4,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                    new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 170, 200, 130, 80, 0),
                },
                 new List<Entity>
                {
                     new Entity
                     (
                         new MovingSprite(new Rectangle(30, 560, 20, 20), new int[]{4,1}, new int[]{1,0},Color.Red, 0)
                     ),
                 },
                   new int[]
            {
        10, //largestSize
        1,  //largestSubtraction
        40, //redAddition
        1, //greenAddition
        1, //blueAddition
        2,  //bioluminescenceSize

        1,  //sampleSuppressor

        45, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
            #endregion
            #region 0,1
            new Level
            (
                new List<int>{
                    30,
                         4,7,7,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                7,4,1,7,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                4,4,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                7,7,7,7,7,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                    30,
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,7,7,7,1,1,10,10,100,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                0,0,7,7,7,1,1,10,10,100,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                0,0,7,7,7,40,100,100,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,-30,-1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                0,0,10,20,30,40,50,60,70,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,
                0,0,7,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,
                0,0,7,7,7,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -60, 0, -180 }, 170, 200, 130, 80, 0),
                      new Light(new Rectangle(580, 320, 0, 0), new int[] { -180, -60, 0 }, 170, 230, 130, 180, 0),
                       //new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 100, 220, 40, 10, 0),
                new Light(new Rectangle(982, 220, 0, 0), new int[] { -12, -6, -39 }, 3, 230, 20, 5, 1),
                },
                 new List<Entity>
                {
                      new Entity
                     (
                         new MovingSprite(new Rectangle(560, 420, 20, 20), new int[]{1,1}, new int[]{1,-1},Color.Orange, 0)
                     ),
                },
                   new int[]
            {
             10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 0,2
            new Level
            (
                new List<int>{
                                 30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,7,7,7,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                        4,4,7,7,7,1,1,7,7,7,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                  30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -180, -60, 0 }, 170, 200, 130, 80, 0),
                       new Light(new Rectangle(980, 820, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 0)
    },
                 new List<Entity>
                {
                },
                   new int[]
            {
                10, //largestSize
        1,  //largestSubtraction
        1, //redAddition
        40, //greenAddition
        30, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 0,3
            new Level
            (
                new List<int>{
                                 30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,1,1,1,1,1,1,1,4,4,1,1,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,7,7,7,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,
                        4,4,7,7,7,1,1,7,7,7,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,1,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                  30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        0,0,1,1,1,1,1,7,7,7,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,2,2,2,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -10, -160, 0 }, 170, 200, 130, 80, 0),
                       new Light(new Rectangle(0, -100, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 1),
                       new Light(new Rectangle(1000, -100, 0, 0), new int[] { 15, 10, -180 }, 100, 220, 40, 10, 0),
    },
                 new List<Entity>
                {
                },
                   new int[]
            {
               10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
        },
        
        //Y = 1
        new Level[]
        {
            #region 1,0
            new Level
            (
                new List<int>{
                  30,
                        16,16,16,16,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,17,17,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,16,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,18,7,18,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,11,18,18,18,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,15,15,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,13,13,13,13,7,7,7,15,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,18,7,14,14,14,13,7,13,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,18,7,7,7,18,7,14,7,14,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,11,
                },
                new List<int>
                {
                          30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,8,6,5,5,1,1,1,1,0,1,2,3,4,5,6,7,0,0,0,0,0,0,0,0,
                        0,0,1,3,7,9,9,7,7,7,1,1,1,1,1,3,4,4,6,7,8,8,1,1,1,0,0,0,0,0,
                        0,0,7,7,7,9,9,7,7,7,5,5,1,1,0,3,4,5,6,7,8,9,1,1,1,1,1,0,0,0,
                        0,0,1,3,7,9,7,4,5,5,7,5,1,1,0,2,2,4,5,4,7,1,1,1,1,1,1,0,0,0,
                        0,0,1,3,7,9,7,4,1,1,7,1,1,1,0,0,0,0,5,5,6,1,1,1,1,1,1,0,0,0,
                        0,0,1,3,3,3,3,4,1,1,1,1,1,1,0,1,2,3,2,4,5,1,1,1,1,1,0,0,0,0,
                        0,0,1,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,4,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,1,1,2,3,3,7,1,1,1,7,1,1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,
                        0,1,2,3,4,4,7,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,4,3,2,1,1,1,1,1,
                        0,0,3,4,5,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,6,5,4,3,1,0,0,0,0,
                        0,0,2,3,4,5,1,1,1,1,1,1,1,1,0,1,1,1,1,1,4,5,4,3,2,1,0,0,0,0,
                        0,0,1,2,3,4,1,1,1,1,1,1,1,1,0,1,1,1,1,1,3,4,3,2,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                    new Light(new Rectangle(580, 320, 0, 0), new int[] { 40000,400000,40000 },4440, 2400, 4130, 8440, 0),
                          new Light(new Rectangle(580, 320, 0, 0), new int[] { -180, -60, 0 }, 170, 230, 130, 80, 1),
                    new Light(new Rectangle(380, 120, 0, 0), new int[] { 32, 0, 29 }, 80, 200, 50, 30, 0),
                    new Light(new Rectangle(380, 120, 0, 0), new int[] { 32, 0, 29 }, 80, 210, 50, 30, 0),
                    new Light(new Rectangle(180,120, 0, 0), new int[] { 32, 12, -29 }, 80, 200, 50, 30, 0),

                },
                 new List<Entity>
                {
                          new Entity
                     (
                         new MovingSprite(new Rectangle(560, 420, 20, 20), new int[]{2,3}, new int[]{-1,1},Color.Lime, 0)
                     ),
                },
                   new int[]
            {
               10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        40, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
            #endregion
            #region 1,1
            new Level
            (
                new List<int>{
                      30,
                        16,16,16,16,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,17,17,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,16,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,7,7,7,18,7,18,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,11,18,18,18,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,16,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,7,7,12,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,12,7,7,7,7,7,7,7,7,15,15,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,13,13,13,13,7,7,7,15,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,18,7,14,14,14,13,7,13,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,18,7,7,7,18,7,14,7,14,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,18,11,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,17,7,7,7,7,7,
                        7,7,7,7,17,7,7,7,7,7,18,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,11,

                },
                new List<int>
                {
       30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
                        0,0,7,7,7,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                        1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                                      new Light(new Rectangle(580, 320, 0, 0), new int[] { 40000,400000,40000 },4440, 2400, 4130, 8440, 0),
                //new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 100, 220, 40, 10, 0),
                new Light(new Rectangle(980, 620, 0, 0), new int[] { -122, -26, -329 }, 70, 200, 40, 5, 0),
                },
                 new List<Entity>
                {
                },
                   new int[]
            {
        50, //largestSize
        1,  //largestSubtraction
        10, //redAddition
        50, //greenAddition
        20, //blueAddition
        5,  //bioluminescenceSize

        4,  //sampleSuppressor

        45, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                ),
#endregion
            #region 1,2
            new Level
            (
                new List<int>{
                                  30,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,1,1,1,1,1,1,1,4,7,1,7,1,1,1,1,4,4,4,4,4,4,4,4,
                        4,4,1,1,7,1,1,7,7,7,1,1,1,1,4,1,1,1,1,1,1,1,1,1,4,4,4,4,4,4,
                        4,4,7,7,7,1,1,7,7,7,1,1,1,1,4,7,1,1,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,1,1,1,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,7,1,7,1,1,1,7,1,1,1,4,4,4,4,1,1,1,1,1,1,4,1,1,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,4,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,1,1,1,1,1,1,4,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,
                        4,4,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,4,4,4,4,4,4,4,4,
                        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,

                },
                new List<int>
                {
                               30,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,1,1,1,1,1,1,1,0,7,1,7,1,1,1,1,0,0,0,0,0,0,0,0,
                        0,0,1,1,7,1,1,7,7,7,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
                        0,0,7,7,7,1,1,7,7,7,1,1,1,1,0,7,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,7,1,7,1,1,1,7,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
                        0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                },
                new List<Light>
                {
                       new Light(new Rectangle(580, 320, 0, 0), new int[] { -52, 3, -180 }, 100, 230, 10, 130, 0),
                       new Light(new Rectangle(980, 520, 0, 0), new int[] { -60, -120, -180 }, 10, 240, 40, 10, 0),
                         new Light(new Rectangle(380, 420, 0, 0), new int[] { -60, -120, -180 }, 60, 100, 40, 10, -1)
    },
                 new List<Entity>
                {
                },
                   new int[]
            {
                10, //largestSize
        1,  //largestSubtraction
        30, //redAddition
        20, //greenAddition
        1, //blueAddition
        0,  //bioluminescenceSize

        1,  //sampleSuppressor

        25, //chanceOfSpawn
        90, //chanceOfRemoval
    }
                )
#endregion
        },
        
        //Y = 2
        new Level[]
        {

        },
        };
        #endregion

        #region ALL TILE PATTERNS:
        int[][] tilePatterns = new int[][]
        {
        new int[]{
            3,
            10,10,10,
            16,10,16,
            10,10,100,
        },
        new int[]{
           3,
              6,6,6,
            10,100,10,
            6,6,6,
        },
         new int[]{
            3,
            2,2,2,
            1,1,2,
            1,2,2,
        },
             new int[]{
            3,
            1,0,0,
            0,1,0,
            0,0,1,
        },
        new int[]{
            3,
            1,1,1,
            1,0,1,
            1,1,1,
        },
          new int[]{
            3,
     1,0,1,
     1,3,1,
     1,1,1,
        },
              new int[]{
            3,
            1,0,1,
            2,3,2,
            3,2,0,
        },
              new int[]{ //7
            15,
          1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,4,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,3,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,3,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,3,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,2,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,2,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
            1,2,3,3,1,2,3,4,3,2,1,2,3,3,1,
            1,3,1,2,1,2,4,2,2,2,1,3,1,2,1,
            1,2,3,2,1,2,3,4,3,2,1,2,3,2,1,
            1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,
        },
            new int[]{ //8
            3,
            3,2,4,
            2,3,2,
            1,1,0,
        },
               new int[]{ // 9
            3,
            0,1,8,
            1,5,6,
            10,13,12,
        },
                    new int[]{ // 10
            3,
            1,1,1,
            7,8,7,
            10,8,12,
        },
                       new int[]{ //11
            15,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        },
            new int[]{ //12
            15,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,3,4,4,2,2,3,4,4,2,2,3,4,4,2,
            2,4,2,3,2,2,4,2,3,2,2,4,2,3,2,
            2,3,4,3,2,2,3,4,3,2,2,3,4,3,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,2,3,3,1,1,2,3,3,1,1,2,3,3,1,
            1,3,1,2,1,1,3,1,2,1,1,3,1,2,1,
            1,2,3,2,1,1,2,3,2,1,1,2,3,2,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        },
               new int[]{ //13
             15,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,5,
            2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,5,
            2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,5,
            2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,5,
            2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,
            1,2,5,1,2,5,1,2,5,1,2,5,1,2,5,
            2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,
            5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,
        },
                 new int[]{ //14
             15,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,1,0,1,3,3,1,0,1,3,3,1,0,1,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,1,0,1,3,3,1,0,1,3,3,1,0,1,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,1,0,1,3,3,1,0,1,3,3,1,0,1,3,
         2,3,1,3,2,2,3,1,3,2,2,3,1,3,2,
         3,2,3,2,3,3,2,3,2,3,3,2,3,2,3,
                 },
                 new int[]{ //15
             15,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
                 },
                           new int[]{ //16
             15,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,
            1,0,0,1,1,2,3,4,3,2,1,1,0,0,1,
            0,2,3,0,2,3,4,5,4,3,2,0,3,2,0,
            0,3,4,5,4,4,4,4,4,4,4,4,4,3,0,

                           },
                                new int[]{ //17
             15,
             1,3,0,0,1,1,0,0,0,1,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,4,5,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,4,0,0,0,0,0,1,
             2,1,2,3,2,1,0,2,2,0,0,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,
             2,1,4,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,0,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,4,5,1,1,5,0,0,0,1,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,1,0,0,0,1,
             5,2,1,0,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,2,0,4,1,0,0,0,0,1,
             2,0,0,0,2,1,0,0,0,2,0,0,0,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
                 },
                                new int[]{ //18
             15,
             0,0,0,10,0,0,0,0,5,0,0,0,10,10,1,
             0,0,10,0,0,0,0,0,0,0,11,10,0,0,1,
             5,4,1,12,5,1,0,0,2,5,1,2,3,2,1,
             1,0,0,1,11,1,0,0,4,0,10,0,10,0,1,
             2,1,2,3,1,1,5,2,2,0,10,0,10,0,1,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,1,
             1,0,0,0,1,1,1,0,0,0,1,0,10,0,2,
             2,1,4,0,21,11,10,2,10,2,1,10,10,10,7,
             5,2,10,2,5,1,2,3,3,5,1,2,3,2,6,
             1,10,4,5,1,1,5,7,10,2,1,10,10,10,5,
             2,10,10,10,2,1,1,3,3,2,3,10,10,10,4,
             5,2,1,0,5,1,2,3,4,5,1,2,3,2,3,
             1,10,10,10,1,1,2,10,5,5,10,10,3,10,3,
             2,10,10,10,2,1,10,10,10,2,10,10,10,3,2,
             5,2,3,2,5,1,2,3,2,5,1,2,3,2,2,
                 },
        };
        #endregion

        #region Load
        public Form1()
        {

            InitializeComponent();
            player = new Rectangle(580, 320, 0, 0);
            lightList.Add(new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 100, 220, 40, 10, 0));
            lightList.Add(new Light(new Rectangle(580, 320, 0, 0), new int[] { 0, -60, -180 }, 10, 10, 10, 10, 0));
            playerXCheck = new Rectangle(0, 0, 0, 0);
            playerYCheck = new Rectangle(0, 0, 0, 0);



            //lightList.Add(new Light(new Rectangle(680, 120, 0, 0), new int[] { 6, -126, -39 }, 80, 240, 50, 30, 0));
            //lightList.Add(new Light(new Rectangle(980, 620, 0, 0), new int[] { -122, -6, -39 }, 70, 200, 40, 5, 0));

            createLevel();

            stopwatch.Start();
        }
        #endregion

        #region Game Timer
        private void gameTimer_Tick(object sender, EventArgs e)
        {
            #region Adding Atmospheric Moving Sprites
            //Add vines or plants growing!
            if (random.Next(0, 101) > chanceOfSpawn && movingSprites.Count < maxSprites)
            {
                sampleSpriteSize = random.Next(0, largestSize) / random.Next(1, largestSubtraction);
                int smallerSize = sampleSpriteSize / random.Next(2, 8);
                int red = random.Next(0, redAddition);
                int green = random.Next(0, greenAddition);
                int blue = random.Next(0, blueAddition);
                int yLoc = 0;

                movingSprites.Add(new MovingSprite(new Rectangle(random.Next(0, this.Width - sampleSpriteSize), yLoc, sampleSpriteSize, sampleSpriteSize), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, Color.FromArgb(red, green, blue), random.Next(-3, 13)));
                movingSprites.Add(new MovingSprite(new Rectangle(random.Next(0, this.Width - smallerSize), yLoc - smallerSize, smallerSize, smallerSize), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, Color.FromArgb(red / 2, green / 2, blue / 2), random.Next(-3, 13)));
            }

            if (random.Next(0, 101) > chanceOfRemoval && movingSprites.Count > 0)
            {
                if (movingSprites[0].body.Width > 16 && movingSprites.Count < maxSprites)
                {
                    movingSprites.Add(new MovingSprite(new Rectangle(movingSprites[0].body.X + movingSprites[0].body.Width / 2, movingSprites[0].body.Y, movingSprites[0].body.Width / 4, movingSprites[0].body.Width / 4), new int[] { 0, random.Next(1, 18) }, new int[] { 0, 1 }, movingSprites[0].color, random.Next(0, 3)));
                }
                movingSprites.RemoveAt(0);
            }
            #endregion
            #region Movement
            oldPlayer = player;

            if (stopwatch.ElapsedMilliseconds % speedInteger == 0)
            {
                //Find out how fast the player should be moving Horizontally!
                //gaining momentum based on walking time
                if (xYSpeed[x] < maxSpeedX && xYDirection[x] != 0) { xYSpeed[x] += momentumGain; }
                //losing momentum over time
                else if (xYSpeed[x] > momentumLoss && xYDirection[x] == 0) { xYSpeed[x] -= momentumLoss; }
            }


            if (WSAD[0] == true && canMoveUpDownLeftRight[down] == 1)
            {
                newJump();
            }
            //Resting: jump speed is at 0
            else if (canMoveUpDownLeftRight[down] == 1)
            {
                xYSpeed[y] = 3;
            }
            //Lifting: decrease speed
            if (jumpState == "decelerating")
            {
                xYDirection[y] = -1;
                if (xYSpeed[y] > 2)
                {
                    xYSpeed[y] -= 2;
                }

                if (WSAD[0] == false || stopwatch.ElapsedMilliseconds - previousJump > jumpInterval / 2 || (canMoveUpDownLeftRight[up] == -1 && stopwatch.ElapsedMilliseconds - previousJump > jumpInterval / 3))
                {
                    xYSpeed[y] = 0;
                    jumpState = "accelerating";
                }
            }
            //Falling: increase speed
            if (jumpState == "accelerating")
            {
                xYDirection[y] = 1;
                if (xYSpeed[y] < maxSpeedY)
                {
                    xYSpeed[y] += 2;
                }
            }

            #endregion
            #region Determing All Object Directions
            //Determening player directions depending on what keys are pressed:
            if (WSAD[left] == true && WSAD[right] == false)
            {
                xYDirection[x] = -1;
            }
            else if (WSAD[left] == false && WSAD[right] == true)
            {
                xYDirection[x] = 1;
            }
            else
            {
                xYDirection[x] = 0;
            }
            #endregion

            try
            {
                foreach (Entity entity in currentEntities)
                {
                    //Should the enemy despawn?
                    if (entity.immortal == false && stopwatch.ElapsedMilliseconds - entity.birth > entity.lifespan)
                    {
                        currentEntities.Remove(entity);
                    }

                    redrawList.Add(new Rectangle(entity.sprite.body.X, entity.sprite.body.Y, entity.sprite.body.Width, entity.sprite.body.Height));

                    //Check for moving through levels
                    int levelXChange = entity.levelPassCheck(this.Height, this.Width).Item1;
                    int levelYChange = entity.levelPassCheck(this.Height, this.Width).Item2;
                    int xCoord = entity.levelPassCheck(this.Height, this.Width).Item3;
                    int yCoord = entity.levelPassCheck(this.Height, this.Width).Item4;

                    //if entity has passed through a level, change its position, add it to the level, and remove them from this current level
                    if (levelXChange != 0 || levelYChange != 0)
                    {
                        entity.sprite.body.Location = new Point(xCoord, yCoord);
                        allLevels[currentLevelY + levelYChange][currentLevelX + levelXChange].entities.Add(entity);
                        currentEntities.Remove(entity);
                    }
                    else
                    {

                        //Move entities
                        entity.adjustSpeeds(Convert.ToInt32(stopwatch.ElapsedMilliseconds), player);
                        entity.moveEntity(currentTiles, currentLevelY, currentLevelX, allLevels);

                    }
                }
            }
            catch { }


            #region Move Player TRY 2

            canMoveUpDownLeftRight[up] = 0;
            canMoveUpDownLeftRight[down] = 0;
            canMoveUpDownLeftRight[left] = 0;
            canMoveUpDownLeftRight[right] = 0;

            //Rectangle to check the players next move
            Rectangle proposedMove = new Rectangle(player.X, player.Y, player.Width, player.Height);

            //Move the rectangle to be in players position
            int Xmove = xYDirection[x] * xYSpeed[x];
            int Ymove = xYDirection[y] * xYSpeed[y];

            proposedMove.X += Xmove;
            proposedMove.Y += Ymove;

            //For each tile, does the new move interstect with it?
            for (int n = 0; n < currentTiles.Count; n++)
            {
                #region UpDownLeftRight
                //CAN PLAYER GO UP DOWN LEFT RIGHT
                if (playerYCheck.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    //TOP WALL
                    if (playerYCheck.Y >= currentTiles[n].Y && n + 30 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 30] != 0)
                    {
                        canMoveUpDownLeftRight[up] = -1;
                    }
                    //BOTTOM WALL
                    if (playerYCheck.Y <= currentTiles[n].Y && n - 30 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 30] != 0)
                    {

                        canMoveUpDownLeftRight[down] = 1;

                    }
                }
                if (playerXCheck.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    //LEFT WALL
                    if (playerXCheck.X >= currentTiles[n].X && n + 1 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 1] != 0)
                    {
                        canMoveUpDownLeftRight[left] = -1;
                    }
                    //RIGHT WALL
                    if (playerXCheck.X <= currentTiles[n].X && n - 1 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 1] != 0)
                    {
                        canMoveUpDownLeftRight[right] = 1;
                    }
                }
                #endregion

                if (proposedMove.IntersectsWith(currentTiles[n]) && allLevels[currentLevelY][currentLevelX].depths[n] == 0)
                {
                    int Xdistance = Math.Abs((currentTiles[n].X + (currentTiles[n].Width / 2)) - (player.X + (player.Width / 2)));
                    int Ydistance = Math.Abs((currentTiles[n].Y + (currentTiles[n].Height / 2)) - (player.Y + (player.Height / 2)));

                    //If the player would not be where they are supposed to be.. find how far they can go!
                    //LEFT WALL
                    if (player.X >= currentTiles[n].X && n + 1 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 1] != 0 && Xdistance > Ydistance)
                    {
                        Xmove = (player.X - (currentTiles[n].Width + currentTiles[n].X)) * -1;
                    }
                    //RIGHT WALL
                    else if (player.X <= currentTiles[n].X && n - 1 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 1] != 0 && Xdistance > Ydistance)

                    {
                        Xmove = currentTiles[n].X - player.X - player.Width;
                    }
                    //TOP WALL
                    else if (player.Y >= currentTiles[n].Y && n + 30 <= currentTiles.Count && allLevels[currentLevelY][currentLevelX].depths[n + 30] != 0 && Xdistance < Ydistance)
                    {
                        Ymove = (player.Y - (currentTiles[n].Y + currentTiles[n].Height)) * -1;
                    }
                    //BOTTOM WALL
                    else if (player.Y <= currentTiles[n].Y && n - 30 >= 0 && allLevels[currentLevelY][currentLevelX].depths[n - 30] != 0 && Xdistance < Ydistance)
                    {
                        Ymove = currentTiles[n].Y - player.Y - player.Height;
                    }
                }
            }
            //Finally move the player.

            if (xYDirection[x] != canMoveUpDownLeftRight[left] && xYDirection[x] != canMoveUpDownLeftRight[right])
            {
                player.X += Xmove;
            }

            if (xYDirection[y] != canMoveUpDownLeftRight[up] && xYDirection[y] != canMoveUpDownLeftRight[down])
            {
                player.Y += Ymove;
            }

            #endregion
            #region Passing Through Levels
            if (player.Y <= player.Height / 2)
            {
                player.Y = this.Height - player.Height;
                currentLevelY--;
                createLevel();
                newJump();
            }
            if (player.Y >= this.Height - player.Height / 2)
            {
                player.Y = player.Height;
                currentLevelY++;
                createLevel();
            }
            if (player.X <= player.Height / 2)
            {
                player.X = this.Width - player.Height;
                currentLevelX--;
                createLevel();
            }
            if (player.X >= this.Width - player.Height / 2)
            {
                player.X = player.Height;
                currentLevelX++;
                createLevel();
            }
            #endregion

            //Tracking player accessories
            playerXCheck.Location = new Point(player.X - 1, player.Y);
            playerYCheck.Location = new Point(player.X, player.Y - 1);
            lightList[0].body.Location = new Point(player.X + (player.Width / 2), player.Y + (player.Width / 2));

            //My info
            levelRenderer(false);

            //Move Moving Sprites
            for (int i = 0; i < movingSprites.Count; i++)
            {
                //move the sprite
                movingSprites[i].body.Y += movingSprites[i].xySpeed[y];
                //if the sprite is off the screen remove the sprite
                if (movingSprites[i].body.Y > this.Height - movingSprites[i].body.Height)
                {
                    movingSprites.RemoveAt(i);
                }
            }
            redrawList.Add(oldPlayer);
        }
        #endregion

        #region Key Checks
        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {
            //Check all keys and if they are down set the boolian value to true
            checkKey(true, e);
        }

        private void Form1_KeyUp(object sender, KeyEventArgs e)
        {
            //Check all keys and if they are up set the boolian value to false
            checkKey(false, e);
        }

        void checkKey(bool trueOrFalse, KeyEventArgs e)
        {
            for (int i = 0; i < keysToCheck.Length; i++)
            {
                if (e.KeyCode == keysToCheck[i])
                {
                    WSAD[i] = trueOrFalse;
                }
            }
        }
        #endregion

        #region Create Level
        private void createLevel()
        {
            Level level = allLevels[currentLevelY][currentLevelX];

            #region vines

            largestSize = level.vineInfo[0];
            largestSubtraction = level.vineInfo[1];
            redAddition = level.vineInfo[2];
            greenAddition = level.vineInfo[3];
            blueAddition = level.vineInfo[4];
            bioluminescenceSize = level.vineInfo[5];
            sampleSuppressor = level.vineInfo[6];
            chanceOfSpawn = level.vineInfo[7];
            chanceOfRemoval = level.vineInfo[8];

            #endregion

            this.Width = tileWidth * 30;
            this.Height = tileWidth * ((level.depths.Count - 1) / 30);
            this.CenterToScreen();
            //Reset the current loaded level
            currentTiles.Clear();
            currentPixelDepths.Clear();
            currentTileDepths.Clear();
            currentTilePixels.Clear();
            currentPixelColors.Clear();
            movingSprites.Clear();
            currentOverlayColors = level.OverlayColors;
            currentEntities = level.entities;
            lightList = level.lights;


            //levelY keeps track of the 'Y' axis of the tile we are placing in the level
            int levelY = 0;
            //n represents the current tile
            for (int n = 0; n < level.depths.Count; n++)
            {
                //levelX works like levelY but for the x coodinate; first it is set to tile value, and then has the board width subtracted from it until it fits from 1 to level[0]
                int levelX = n;
                while (levelX > level.depths[0])
                {
                    levelX -= level.depths[0];
                }
                int rectangleX = ((levelX - 1) * tileWidth);
                int rectangleY = ((levelY - 1) * tileWidth);

                //Now that we have the x and y point of the rectangle, put it into physical space
                currentTiles.Add(new Rectangle(rectangleX, rectangleY, tileWidth, tileWidth));

                //Now we have a boundary for where the player can go, we still need to place in the image
                if (n > 0 && n <= 540)
                {
                    int thisTile = level.tileSprites[n];
                    int tilePixelY = 0;
                    int pixelDimension = tileWidth / tilePatterns[thisTile][0];

                    for (int m = 0; m < tilePatterns[thisTile].Length; m++)
                    {
                        int tilePixelX = m;
                        while (tilePixelX > tilePatterns[thisTile][0])
                        {
                            tilePixelX -= tilePatterns[thisTile][0];
                        }

                        int pixelX = (tilePixelX - 1) * pixelDimension;
                        int pixelY = (tilePixelY - 1) * pixelDimension;
                        //Now that we have the x and y point of the rectangle, put it (one pixel of the rectangle) into physical space, aswell as adding the integer storing its color value into its list.
                        if (m > 0)
                        {
                            currentTilePixels.Add(new Rectangle(pixelX + rectangleX, pixelY + rectangleY, pixelDimension, pixelDimension));
                            currentPixelDepths.Add(tilePatterns[thisTile][m] + (level.depths[n]));
                            currentTileDepths.Add(level.depths[n]);
                            currentPixelColors.Add(Color.Black);
                        }
                        if ((m) % (tilePatterns[thisTile][0]) == 0)
                        {
                            //If we get to the end of a row, add one to levelY to move us down a row, and reset levelX to 1 (the begining of the row)
                            tilePixelY++;
                        }
                    }
                }
                if ((n) % (level.depths[0]) == 0)
                {
                    //If we get to the end of a row, add one to levelY to move us down a row, and reset levelX to 1 (the begining of the row)
                    levelY++;
                }

            }
            if (level.OverlayColors.Count == currentPixelColors.Count)
            { }
            else
            {
                currentOverlayColors.Clear();
                for (int i = 0; i < currentPixelColors.Count; i++) { level.OverlayColors.Add(Color.FromArgb(255, 255, 255, 255)); };
            }
            currentOverlayColors = level.OverlayColors;

            int playerSize = Convert.ToInt32(tileWidth * 0.7);
            player.Size = new Size(playerSize, playerSize);

            lightList[0].body.Location = new Point(player.X - playerSize / 2, player.Y - playerSize / 2);
            playerXCheck = new Rectangle(0, 0, playerSize + 2, playerSize); ;
            playerYCheck = new Rectangle(0, 0, playerSize, playerSize + 2);
            //Define Graphics
            e = this.CreateGraphics();

            //If we are in a large level
            if (currentTilePixels.Count > 70000)
            {
                //set the current paint method to a large room renderer
                levelRenderer = largePaint;

            }
            //otherwise
            else
            {
                //set the current paint method to a large room renderer
                levelRenderer = smallPaint;
            }
            levelRenderer(true);
        }
        #endregion

        double GetLength(Rectangle rectangle1, Rectangle rectangle2)
        {

            double x1 = rectangle1.X + (rectangle1.Width / 2);
            double x2 = rectangle2.X + (rectangle2.Width / 2);
            double y1 = rectangle1.Y + (rectangle1.Height / 2);
            double y2 = rectangle2.Y + (rectangle2.Height / 2);

            //A^2 = B^2 + C^2
            double length = Math.Sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
            return length;
        }

        //This version of paint doesnt refresh the screen each time! instead of drawing 5000 pixels it only draws the ones that change! This took my 'Process Memory' panel output number from 56 to 32!

        #region Large Paint
        void largePaint(bool loadWholeLevel)
        {
            if (loadWholeLevel) { Refresh(); }

            //For each rectangle on screen
            for (int n = 0; n < currentTilePixels.Count; n++)
            {
                VineGrowth(n);

                //REDRAWING

                int redrawSample = redrawCheck(currentTilePixels[n], redrawList);

                if (loadWholeLevel == true || redrawSample != -1)
                {
                    //Reset the trueRgb array
                    trueRgb = new double[3] { 0, 0, 0 };

                    if (currentOverlayColors[n] != Color.FromArgb(255, 255, 255, 255)) { sampleColor = currentOverlayColors[n]; }
                    else
                    {
                        //For each light that can affect the rectangle (lights on screen)
                        for (int i = Convert.ToInt32(loadWholeLevel); i < lightList.Count; i++)
                        {
                            //For each Red, Green, Or blue value of the rectangle's color
                            for (int num = 0; num < 3; num++)
                            {
                                //If the rectangle is in range of the light (rectangle would not be siloughetted by the light in 3D space)
                                if (currentPixelDepths[n] > lightList[i].depth)
                                {
                                    lightList[i].rgbStorage[num] = (20000 / GetLength(lightList[i].body, currentTilePixels[n]) / (currentPixelDepths[n] - (lightList[i].depth))) + lightList[i].rgbAffectors[num];
                                }
                                if (lightList[i].rgbStorage[num] > lightList[i].lightenPoint) { lightList[i].rgbStorage[num] += 20; }
                                if (lightList[i].rgbStorage[num] > lightList[i].maxBright) { lightList[i].rgbStorage[num] = lightList[i].maxBright; }
                                if (lightList[i].rgbStorage[num] < lightList[i].darkenPoint) { lightList[i].rgbStorage[num] -= 12; }
                                if (lightList[i].rgbStorage[num] < lightList[i].blackPoint) { lightList[i].rgbStorage[num] = 0; }
                            }
                            //Now that we have found the way the lights affect all pixels, find the brightest light per pixel
                            for (int j = 0; j < 3; j++)
                            {
                                if (lightList[i].rgbStorage[j] > trueRgb[j] && currentTileDepths[n] >= lightList[i].depth)
                                {
                                    trueRgb[j] = lightList[i].rgbStorage[j];
                                }
                            }
                        }
                        sampleColor = (Color.FromArgb(Convert.ToInt32(trueRgb[0]), Convert.ToInt32(trueRgb[1]), Convert.ToInt32(trueRgb[2])));
                    }

                    //To avoid drawing things over again (This is reducing lag!)
                    if (currentPixelColors[n] != sampleColor || currentTilePixels[n].IntersectsWith(oldPlayer) || redrawSample != -1)
                    {
                        currentPixelColors[n] = sampleColor;
                        //try { 
                        e.FillRectangle(new SolidBrush(currentPixelColors[n]), currentTilePixels[n]);
                        //}
                        //catch { }

                        //If we would be covering the player, redraw the player. We *SHOULD* be able to draw the player only once at the end, however because it takes a long time to render each tile, there is a noticable flicker.
                        if (currentTilePixels[n].IntersectsWith(player))
                        { e.FillRectangle(whiteBrush, player); }
                        if (redrawSample != -1 && currentEntities.Count > redrawSample)
                        {
                            e.FillRectangle(new SolidBrush(currentEntities[redrawSample].sprite.color), currentEntities[redrawSample].sprite.body);
                        }
                    }
                }
            }

            e.FillRectangle(whiteBrush, player);
            drawEntities();
            redrawList.Clear();
        }
        #endregion

        #region Small Paint
        void smallPaint(bool loadWholeLevel)
        {
            if (loadWholeLevel) { Refresh(); }

            //For each rectangle on screen
            for (int n = 0; n < currentTilePixels.Count; n++)
            {
                VineGrowth(n);

                //Reset the trueRgb array
                trueRgb = new double[3] { 0, 0, 0 };


                if (currentOverlayColors[n] != Color.FromArgb(255,255,255,255) && ((currentOverlayColors[n].R + currentOverlayColors[n].G + currentOverlayColors[n].B) / 3) < 150)
                {
                    sampleColor = currentOverlayColors[n];
                }
                else
                {
                    //For each light that can affect the rectangle (lights on screen)
                    for (int i = Convert.ToInt32(loadWholeLevel); i < lightList.Count; i++)
                    {
                        //For each Red, Green, Or blue value of the rectangle's color
                        for (int num = 0; num < 3; num++)
                        {
                            //If the rectangle is in range of the light (rectangle would not be siloughetted by the light in 3D space)
                            if (currentTileDepths[n] >= lightList[i].depth && currentPixelDepths[n] > lightList[i].depth)
                            {
                                lightList[i].rgbStorage[num] = (20000 / GetLength(lightList[i].body, currentTilePixels[n]) / (currentPixelDepths[n] - (lightList[i].depth))) + lightList[i].rgbAffectors[num];
                            }
                            if (lightList[i].rgbStorage[num] > lightList[i].lightenPoint) { lightList[i].rgbStorage[num] += 20; }
                            if (lightList[i].rgbStorage[num] > lightList[i].maxBright) { lightList[i].rgbStorage[num] = lightList[i].maxBright; }
                            if (lightList[i].rgbStorage[num] < lightList[i].darkenPoint) { lightList[i].rgbStorage[num] -= 12; }
                            if (lightList[i].rgbStorage[num] < lightList[i].blackPoint) { lightList[i].rgbStorage[num] = 0; }
                        }
                        //Now that we have found the way the lights affect all pixels, find the brightest light per pixel
                        for (int j = 0; j < 3; j++)
                        {
                            if (lightList[i].rgbStorage[j] > trueRgb[j] && currentTileDepths[n] >= lightList[i].depth)
                            {
                                trueRgb[j] = lightList[i].rgbStorage[j];
                            }
                        }
                    }
                    sampleColor = (Color.FromArgb(Convert.ToInt32(trueRgb[0]), Convert.ToInt32(trueRgb[1]), Convert.ToInt32(trueRgb[2])));
                }



                int redrawSample = redrawCheck(currentTilePixels[n], redrawList);

                //To avoid drawing things over again (This is reducing lag!)
                if (currentPixelColors[n] != sampleColor || loadWholeLevel || redrawSample != -1)
                {
                    currentPixelColors[n] = sampleColor;
                    //try {
                    e.FillRectangle(new SolidBrush(currentPixelColors[n]), currentTilePixels[n]);
                    //}
                    //catch { }

                    //If we would be covering the player, redraw the player. We *SHOULD* be able to draw the player only once at the end, however because it takes a long time to render each tile, there is a noticable flicker.
                    if (currentTilePixels[n].IntersectsWith(player))
                    { e.FillRectangle(whiteBrush, player); }
                    if (redrawSample != -1 && currentEntities.Count > redrawSample && currentEntities[redrawSample].sprite.body.IntersectsWith(redrawList[redrawSample]) == false)
                    {
                        e.FillRectangle(new SolidBrush(currentEntities[redrawSample].sprite.color), currentEntities[redrawSample].sprite.body);
                    }
                }
            }
            e.FillRectangle(new SolidBrush(Color.White), player);
            drawEntities();
            redrawList.Clear();
        }
        #endregion

        void newJump()
        {
            xYDirection[y] = -1;
            xYSpeed[y] = maxSpeedY;
            previousJump = Convert.ToInt32(stopwatch.ElapsedMilliseconds);
            jumpState = "decelerating";
        }

        int checkList(int n, List<MovingSprite> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (currentTilePixels[n].IntersectsWith(list[i].body))
                {
                    if (list[i].depth < currentTileDepths[n]) { return i; }
                    else if (list[i].depth > 1) { list[i].depth--; }
                }
            }
            return -1;
        }

        int redrawCheck(Rectangle rectangle, List<Rectangle> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (rectangle.IntersectsWith(list[i]) && player.Contains(rectangle) == false && entityContains(rectangle) == false)
                {
                    return i;
                }
            }
            return -1;
        }

        int overlayCheck(Rectangle rectangle, List<Rectangle> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (rectangle.IntersectsWith(list[i]))
                {
                    return i;
                }
            }
            return -1;
        }

        bool entityContains(Rectangle rectangle)
        {
            foreach (Entity entity in currentEntities)
            {
                if (entity.sprite.body.Contains(rectangle))
                {
                    return true;
                }
            }
            return false;
        }

        void drawEntities()
        {
            foreach (Entity entity in currentEntities) { e.FillRectangle(new SolidBrush(entity.sprite.color), entity.sprite.body); }
        }

        void playerAttack(Size range)
        {
            //Attack position based on entity: Start with entity position, and add attack position based on entity direction
            int xDir = 0;
            int yDir = 0;
            Point _player = new Point(player.X + player.Width / 2, player.Y + player.Height / 2);

            Point attackPoint = new Point(_player.X - range.Width / 2, _player.Y - range.Height / 2);
            #region Attack based on mouse
            Point mouse = new Point(Cursor.Position.X + ((this.Width - Screen.FromControl(this).Bounds.Width) / 2), Cursor.Position.Y + ((this.Height - Screen.FromControl(this).Bounds.Height) / 2));

            int xDiff = (mouse.X - _player.X);
            int yDiff = (mouse.Y - _player.Y);

            if (xDiff != 0 && Math.Abs(xDiff) > 30)
            {
                xDir = xDiff / Math.Abs(xDiff);
            }

            if (yDiff != 0 && Math.Abs(yDiff) > 30)
            {
                yDir = yDiff / Math.Abs(yDiff);
            }
            #endregion
            #region Attack based on direction
            //if (WSAD[0] == false && WSAD[1] == true) { yDir = 1; }
            //else if (WSAD[1] == false && WSAD[0] == true) { yDir = -1; }

            //if (WSAD[2] == false && WSAD[3] == true) { xDir = 1; }
            //else if (WSAD[3] == false && WSAD[2] == true) { xDir = -1; }
            #endregion

            //Create instance of attack entity
            currentEntities.Add(
                new Entity(
                    new MovingSprite(
                        new Rectangle(attackPoint, range),
                        new int[] { 9, 9 },
                        new int[] { xDir, yDir },
                        Color.Red,
                        0),
                    400,
                    Convert.ToInt32(stopwatch.ElapsedMilliseconds)
                    ));

            //previousAttack set to Now
        }

        private void Form1_MouseClick(object sender, MouseEventArgs e)
        {
            playerAttack(new Size(6, 6));
        }


        #region MovingSpriteStuff (vines)
        void VineGrowth(int n)
        {
            //Finds if there is a spot in the Moving Sprites list where the pixel overlaps with a sprite
            int intersectsWith = checkList(n, movingSprites);
            if (intersectsWith != -1) //IF THERE IS AN INTERSECTION:
            {
                //Redraws the pixel if outside the radius of the moving sprite
                if (GetLength(movingSprites[intersectsWith].body, currentTilePixels[n]) > movingSprites[intersectsWith].body.Width / 1.9 && levelRenderer == largePaint)
                {
                    currentOverlayColors[n] = currentPixelColors[n];
                }
                //otherwise draws the pixel as part of the moving sprite
                else if (currentTileDepths[n] >= movingSprites[intersectsWith].depth)
                {
                    //Now we are drawing the actual rectangle:
                    if (movingSprites[intersectsWith].body.Width > bioluminescenceSize) //if the rectangle should get brighter
                    {
                        int[] beforeColor = new int[]
                            {
                            currentPixelColors[n].R + movingSprites[intersectsWith].color.R + sampleColor.R / sampleSuppressor,
                            currentPixelColors[n].G + movingSprites[intersectsWith].color.G + sampleColor.G / sampleSuppressor,
                            currentPixelColors[n].B + movingSprites[intersectsWith].color.B + sampleColor.B / sampleSuppressor
                            };

                        for (int i = 0; i < 3; i++)
                        {
                            if (beforeColor[i] >= 255 || beforeColor[i] <= 1)
                            {
                                beforeColor[i] = (currentPixelColors[n].R + currentPixelColors[n].B + currentPixelColors[n].G) / 3;
                            }
                        }
                        //e.FillRectangle(new SolidBrush(Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2])), currentTilePixels[n]);
                        currentOverlayColors[n] = Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2]);
                    }
                    else //otherwise
                    {
                        int[] beforeColor = new int[]
                        {
                            (currentPixelColors[n].R + movingSprites[intersectsWith].color.R + sampleColor.R / 4),
                            (currentPixelColors[n].G + movingSprites[intersectsWith].color.G + sampleColor.G / 4),
                            (currentPixelColors[n].B + movingSprites[intersectsWith].color.B + sampleColor.B / 4)
                        };

                        for (int i = 0; i < 3; i++)
                        {
                            if (currentTileDepths[n] == 0 || movingSprites[intersectsWith].depth < 1) 
                            {
                                beforeColor[i] += 50;
                            }
                            if (beforeColor[i] >= 255 || beforeColor[i] <= 1)
                            {
                                beforeColor[i] = (currentPixelColors[n].R + currentPixelColors[n].B + currentPixelColors[n].G) / 3;
                            }
                        }
                        //e.FillRectangle(new SolidBrush(Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2])), currentTilePixels[n]);
                        currentOverlayColors[n] = Color.FromArgb(beforeColor[0], beforeColor[1], beforeColor[2]);

                    }

                }
                e.FillRectangle(new SolidBrush(currentOverlayColors[n]), currentTilePixels[n]);
            }

        }
        #endregion
    }
}
